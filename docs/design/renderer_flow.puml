@startuml Renderer Flow

title Renderer Flow Through Application Hierarchy
footer Last Updated: 2025-11-28 | Migration Complete ✅

skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true

participant "main_pyglet.py" as main
participant "BackendRegistry" as registry
participant "GUIBackend" as backend
participant "PygletRenderer" as renderer
participant "PygletEventLoop" as eventloop
participant "Window\n(main_window)" as window
participant "GCubeViewer" as viewer
participant "_Board" as board
participant "_FaceBoard" as faceboard
participant "_Cell" as cell

== Initialization ==

main -> registry : get_backend("pyglet")
activate registry
registry -> backend ** : GUIBackend(name, entry)
registry --> main : backend
deactivate registry

main -> main : AbstractApp.create()

note over main
  Wire up event loop to animation manager:
  app.am.set_event_loop(backend.event_loop)
end note

main -> window : Window(app, 720, 720, title, **backend**)
activate window

window -> backend : backend.renderer
activate backend
backend -> renderer ** : renderer_factory()
note right: Lazy singleton creation\n(only on first access)
backend --> window : renderer
deactivate backend

window -> renderer : setup()
note right: Initializes OpenGL state:\nglClearColor, glEnable(GL_DEPTH_TEST)

window -> viewer : GCubeViewer(cube, vs, **renderer**)
activate viewer

viewer -> board : _Board(cube, vs, **renderer**)
activate board

board -> faceboard : _FaceBoard(self, ...)
activate faceboard
note right
  _FaceBoard stores reference
  to _Board via self._board

  Accesses renderer via:
  self._board.renderer
end note

faceboard -> cell : _Cell(self)
activate cell
note right
  _Cell accesses renderer via property:

  @property
  def renderer(self):
    return self._face_board.board.renderer

  **Renderer is REQUIRED**
  RuntimeError if not configured
end note

deactivate cell
deactivate faceboard
deactivate board
deactivate viewer
deactivate window

== Event Loop (✅ Abstracted) ==

main -> backend : backend.event_loop
activate backend
backend -> eventloop ** : event_loop_factory()
backend --> main : event_loop
deactivate backend

main -> eventloop : run()
activate eventloop
note right: Uses pyglet.app.run()\ninternally

eventloop -> window : process_events()
activate window

window -> window : on_draw()
window -> viewer : draw()
activate viewer

viewer -> board : draw()
activate board

board -> board : _prepare_view_state()

board -> renderer : display_lists.call_lists(lists)
activate renderer
renderer -> renderer : glCallList() for each
deactivate renderer

board -> board : _restore_view_state()

deactivate board
deactivate viewer
deactivate window

deactivate eventloop

== Shape Rendering (inside display list compile) ==

cell -> cell : _update_polygon()
activate cell

cell -> renderer : shapes.quad_with_border(points, color, lw, lc)
activate renderer
renderer -> renderer : gl.glBegin(GL_QUADS)...
deactivate renderer

cell -> renderer : shapes.cross(points, width, color)
activate renderer
renderer -> renderer : gl.glBegin(GL_LINES)...
deactivate renderer

cell -> renderer : shapes.full_cylinder(p1, p2, r_out, r_in, color)
activate renderer
renderer -> renderer : gluCylinder(), gluDisk()
deactivate renderer

deactivate cell

note over cell, renderer
  **No fallback code**
  Renderer is always required
  All rendering goes through renderer.*
end note

@enduml
