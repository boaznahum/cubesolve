# Algorithm Notation Guide

This document describes the algorithm notation used in this Rubik's cube solver.

---

## Standard References

This notation is based on the widely-accepted **Singmaster notation** used by:
- [alg.cubing.net](https://alg.cubing.net/) - Algorithm visualizer
- [SpeedSolving Wiki](https://www.speedsolving.com/wiki/index.php/Notation) - Community reference

---

## Face Moves

### Basic Face Moves (90° clockwise when looking at the face)

| Move | Face | Direction |
|------|------|-----------|
| `R` | Right | Clockwise |
| `L` | Left | Clockwise |
| `U` | Up | Clockwise |
| `D` | Down | Clockwise |
| `F` | Front | Clockwise |
| `B` | Back | Clockwise |

**Agreement with standard:** Full agreement

### Inverse (Prime) Moves

| Notation | Meaning |
|----------|---------|
| `R'` | R counter-clockwise (inverse of R) |
| `U'` | U counter-clockwise (inverse of U) |

**Agreement with standard:** Full agreement

### Double Moves

| Notation | Meaning |
|----------|---------|
| `R2` | R twice (180°) |
| `U2` | U twice (180°) |

**Agreement with standard:** Full agreement

---

## Slice Moves (Middle Layers)

Slice moves rotate the middle layer(s) between two opposite faces.

### Basic Slice Definitions

| Slice | Axis | Reference Face | Rotation Direction |
|-------|------|----------------|-------------------|
| `M` | L ↔ R | **L** | Like L (clockwise when viewing L face) |
| `E` | U ↔ D | **D** | Like D (clockwise when viewing D face) |
| `S` | F ↔ B | **F** | Like F (clockwise when viewing F face) |

### Slice Movement (Content Flow)

```
M: F → U → B → D → F  (vertical cycle, like L rotation)
E: R → B → L → F → R  (horizontal cycle, like D rotation)
S: U → R → D → L → U  (around F/B axis, like F rotation)
```

### API Reference

```python
Algs.M.get_face_name() → FaceName.L  # M rotates like L
Algs.E.get_face_name() → FaceName.D  # E rotates like D
Algs.S.get_face_name() → FaceName.F  # S rotates like F
```

---

## Slice Indexing (NxN Cubes)

### CRITICAL: Indexing is 1-Based

**WARNING:** Slice indices start at **1**, NOT 0!

```python
M[0]  # INVALID! Will cause error
M[1]  # First inner slice - VALID
```

### Number of Slices

For an NxN cube: `n_slices = N - 2` inner slices

| Cube Size | n_slices | Valid Indices |
|-----------|----------|---------------|
| 3x3 | 1 | `[1]` |
| 4x4 | 2 | `[1]`, `[2]` |
| 5x5 | 3 | `[1]`, `[2]`, `[3]` |
| 6x6 | 4 | `[1]`, `[2]`, `[3]`, `[4]` |
| 7x7 | 5 | `[1]`, `[2]`, `[3]`, `[4]`, `[5]` |

### Where Slice[1] Starts

**Slice[1] is always closest to the reference face:**

| Slice | Reference Face | Slice[1] Position |
|-------|----------------|-------------------|
| `M[1]` | L | Closest to **L** face |
| `E[1]` | D | Closest to **D** face |
| `S[1]` | F | Closest to **F** face |

### Visual Example: 5x5 Cube M Slices

Viewing from Front face, looking at L-R cross-section:

```
          L face                              R face
             │                                   │
             │   M[1]  M[2]  M[3]                │
             │     ↓     ↓     ↓                 │
             │   ┌───┐ ┌───┐ ┌───┐               │
             └───┤   ├─┤   ├─┤   ├───────────────┘
                 │   │ │   │ │   │
                 └───┘ └───┘ └───┘
                  ↑           ↑
             closest      closest
              to L         to R
```

### Visual Example: 6x6 Cube E Slices

Viewing from Front face, looking at U-D cross-section:

```
                    U face
             ┌─────────────────┐
             │                 │
             ├─────────────────┤ ← E[4] (closest to U)
             │                 │
             ├─────────────────┤ ← E[3]
             │                 │
             ├─────────────────┤ ← E[2]
             │                 │
             ├─────────────────┤ ← E[1] (closest to D)
             │                 │
             └─────────────────┘
                    D face
```

### Slice Range Notation

Move multiple slices at once using various notations:

#### Output Formats (as generated by algorithms)

| Format | Meaning | Example |
|--------|---------|---------|
| `[start:stop]CODE` | Slices from `start` to `stop` inclusive | `[1:2]M` |
| `[start:]CODE` | Slices from `start` to max | `[1:]M` |
| `[1:stop]CODE` | Slices from 1 to `stop` (default start) | `[1:3]M` |
| `[i1,i2,...]CODE` | Specific slice indices | `[1,3]M` |

#### Parser Input Formats (can be parsed)

```
M[1:2]  - Move slices 1 and 2 together
M[1:3]  - Move slices 1, 2, and 3 together
E[2:4]  - Move slices 2, 3, and 4 together
M[1:]   - Move slices 1 through max
M[1,3]  - Move specific slices 1 and 3
```

**Note:** The output format places brackets BEFORE the algorithm (`[1:2]M`), but this is parsed correctly.

### Examples by Cube Size

**4x4 Cube (2 inner slices):**
```
M[1]    - Inner slice near L
M[2]    - Inner slice near R
M[1:2]  - Both inner slices (equivalent to M on 3x3)
```

**5x5 Cube (3 inner slices):**
```
M[1]    - First inner slice (near L)
M[2]    - Middle slice (true center)
M[3]    - Third inner slice (near R)
M[1:2]  - First two slices
M       - All slices together
```

**7x7 Cube (5 inner slices):**
```
E[1]    - First inner slice (near D)
E[2]    - Second slice
E[3]    - Middle slice (true center)
E[4]    - Fourth slice
E[5]    - Fifth slice (near U)
E[1:3]  - Bottom three inner slices
E[3:5]  - Top three inner slices
```

---

## Whole Cube Rotations

Rotate the entire cube (no pieces move relative to each other, but orientation changes).

| Move | Like Face | Implementation |
|------|-----------|----------------|
| `X` | R | Rotate cube as if doing R (but entire cube) |
| `Y` | U | Rotate cube as if doing U (but entire cube) |
| `Z` | F | Rotate cube as if doing F (but entire cube) |

**Agreement with standard:** Full agreement

---

## Wide Moves

### Double-Layer Moves (Nw notation)

| Move | Meaning |
|------|---------|
| `Rw` | R + adjacent M' (two layers) |
| `Uw` | U + adjacent E' (two layers) |
| `Fw` | F + adjacent S (two layers) |

**Agreement with standard:** Full agreement

### Adaptive Wide Moves (lowercase)

These moves are specific to this solver and adapt to cube size:

| Move | On 3x3 | On NxN |
|------|--------|--------|
| `r` | Same as R | R + all inner layers (L stays fixed) |
| `l` | Same as L | L + all inner layers (R stays fixed) |
| `u` | Same as U | U + all inner layers (D stays fixed) |
| `d` | Same as D | D + all inner layers (U stays fixed) |
| `f` | Same as F | F + all inner layers (B stays fixed) |
| `b` | Same as B | B + all inner layers (F stays fixed) |

**Difference from standard:** In standard notation, lowercase `r` often means `Rw` (2 layers). Our lowercase moves adapt to cube size, moving N-1 layers.

---

## Sequence Notation

### Basic Sequences

```
R U R' U'    # Space-separated moves
```

### Grouped Sequences

```
[R U R' U']     # Bracketed group
(R U R' U')     # Parenthesized group (for repetition)
```

### Repetition

```
(R U R' U')2    # Repeat 2 times
R2             # R twice (special case for single move)
```

**Agreement with standard:** Mostly agrees. Some notations use `(...)2` others use `(...)×2`.

---

## Parser Limitations

The current parser (`_parser.py`) has these limitations:

1. **No exponent N support**: `R3` is not supported (use `R' ` instead)
2. **Basic tokenization**: Complex nested structures may not parse correctly
3. **Case sensitivity**: `r` vs `R` have different meanings (see Adaptive Wide Moves)

---

## String Output Format

When converting an algorithm to string (`str(alg)`):

| Internal State | Output |
|----------------|--------|
| `n = 1` | `R` |
| `n = 2` | `R2` |
| `n = 3` | `R'` |
| `n = 4` (or 0) | `R4` |

Sequences are output as: `[R U R' U']`

Named sequences are output as: `{name}`

---

## Examples

### Input → Parsed → Output

| Input | Parsed OK | Output |
|-------|-----------|--------|
| `R` | Yes | `R` |
| `R'` | Yes | `R'` |
| `R2` | Yes | `R2` |
| `R U R' U'` | Yes | `[R U R' U']` |
| `(R U)2` | Yes | `[R U]2` |
| `M` | Yes | `M` |
| `M[1]` | No (not supported) | - |
| `Rw` | Yes | `Rw` |
| `r` | Yes | `r` (adaptive wide) |

---

## Code Reference

| File | Purpose |
|------|---------|
| `src/cube/domain/algs/_parser.py` | `parse_alg(s)` - String to Alg |
| `src/cube/domain/algs/Alg.py` | Base class, `__str__()` |
| `src/cube/domain/algs/Algs.py` | `Algs.parse(s)`, move constants |
| `src/cube/domain/algs/SimpleAlg.py` | `atomic_str()` implementation |
