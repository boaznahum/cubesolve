============================= test session starts ==============================
platform linux -- Python 3.11.14, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
rootdir: /home/user/cubesolve
configfile: pyproject.toml
plugins: xdist-3.8.0, typeguard-4.4.4
created: 16/16 workers
16 workers [180 items]

scheduling tests via LoadScheduling

tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-3] 
[gw0] [  0%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-3] 
[gw12] [  1%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-3] 
[gw9] [  1%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-4] 
[gw6] [  2%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-3] 
[gw3] [  2%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-3] 
[gw15] [  3%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-4] 
[gw12] [  3%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-8] 
[gw6] [  4%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-5] 
[gw3] [  5%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-8] 
[gw9] [  5%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-5] 
[gw0] [  6%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-5] 
[gw7] [  6%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-6] 
[gw13] [  7%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-6] 
[gw4] [  7%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-6] 
[gw10] [  8%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-6] 
[gw1] [  8%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-6] 
[gw9] [  9%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-6] 
[gw6] [ 10%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-6] 
[gw15] [ 10%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-8] 
[gw0] [ 11%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-6] 
[gw13] [ 11%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-8] 
[gw7] [ 12%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-5] 
[gw4] [ 12%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-4] 
[gw9] [ 13%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-7] 
[gw10] [ 13%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-6] 
[gw1] [ 14%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-8] 
[gw14] [ 15%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-8] 
[gw8] [ 15%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-8] 
[gw6] [ 16%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-6] 
[gw5] [ 16%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-8] 
[gw7] [ 17%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-6] 
[gw2] [ 17%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-8] 
[gw11] [ 18%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-8] 
[gw4] [ 18%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-5] 
[gw0] [ 19%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-7] 
[gw4] [ 20%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-6] 
[gw7] [ 20%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-7] 
[gw3] [ 21%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-3] 
[gw3] [ 21%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-4] 
[gw10] [ 22%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-7] 
[gw9] [ 22%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-4] 
[gw3] [ 23%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-6] 
[gw12] [ 23%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-3] 
[gw12] [ 24%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-4] 
[gw4] [ 25%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-7] 
[gw6] [ 25%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-6] 
[gw12] [ 26%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-B-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-4] 
[gw0] [ 26%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-8] 
[gw12] [ 27%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-4] 
[gw9] [ 27%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-5] 
[gw15] [ 28%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-F-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-3] 
[gw15] [ 28%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-4] 
[gw3] [ 29%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-7] 
[gw15] [ 30%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-3] 
[gw15] [ 30%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-5] 
[gw9] [ 31%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-8] 
[gw7] [ 31%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-7] 
[gw13] [ 32%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-L-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-3] 
[gw13] [ 32%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-8] 
[gw14] [ 33%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-D-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-6] 
[gw8] [ 33%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-R-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-8] 
[gw7] [ 34%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-5] 
[gw6] [ 35%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-7] 
[gw15] [ 35%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-6] 
[gw12] [ 36%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-7] 
[gw5] [ 36%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-B-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-4] 
[gw7] [ 37%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-4] 
[gw10] [ 37%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-8] 
[gw5] [ 38%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-5] 
[gw2] [ 38%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-U-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-8] 
[gw4] [ 39%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-5] 
[gw7] [ 40%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-8] 
[gw11] [ 40%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[F<-L-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-4] 
[gw1] [ 41%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-3] 
[gw1] [ 41%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-6] 
[gw11] [ 42%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-5] 
[gw5] [ 42%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-3] 
[gw5] [ 43%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-3] 
[gw5] [ 43%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-4] 
[gw15] [ 44%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-6] 
[gw4] [ 45%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-4] 
[gw4] [ 45%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-7] 
[gw11] [ 46%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-8] 
[gw3] [ 46%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-4] 
[gw14] [ 47%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-7] 
[gw1] [ 47%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-7] 
[gw5] [ 48%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-5] 
[gw6] [ 48%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-5] 
[gw12] [ 49%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-7] 
[gw0] [ 50%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-3] 
[gw3] [ 50%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-4] 
[gw0] [ 51%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-4] 
[gw15] [ 51%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-6] 
[gw5] [ 52%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-7] 
[gw3] [ 52%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-5] 
[gw0] [ 53%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-6] 
[gw6] [ 53%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-8] 
[gw3] [ 54%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-3] 
[gw3] [ 55%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-6] 
[gw9] [ 55%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-7] 
[gw4] [ 56%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-8] 
[gw0] [ 56%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-4] 
[gw15] [ 57%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-7] 
[gw13] [ 57%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-3] 
[gw1] [ 58%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-6] 
[gw13] [ 58%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-6] 
[gw0] [ 59%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-4] 
[gw14] [ 60%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-5] 
[gw10] [ 60%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-R-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-3] 
[gw10] [ 61%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-5] 
[gw3] [ 61%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-7] 
[gw0] [ 62%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-3] 
[gw0] [ 62%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-8] 
[gw8] [ 63%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-3] 
[gw8] [ 63%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-4] 
[gw12] [ 64%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-3] 
[gw12] [ 65%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-6] 
[gw14] [ 65%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-4] 
[gw7] [ 66%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-B-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-5] 
[gw2] [ 66%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-B-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-3] 
[gw2] [ 67%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-F-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-4] 
[gw8] [ 67%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-5] 
[gw10] [ 68%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-6] 
[gw5] [ 68%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-8] 
[gw14] [ 69%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-8] 
[gw11] [ 70%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-3] 
[gw11] [ 70%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-4] 
[gw7] [ 71%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-F-5] 
[gw1] [ 71%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-7] 
[gw7] [ 72%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-6] 
[gw13] [ 72%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-8] 
[gw11] [ 73%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-5] 
[gw9] [ 73%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-7] 
[gw8] [ 74%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-6] 
[gw2] [ 75%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-5] 
[gw11] [ 75%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-4] 
[gw15] [ 76%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-5] 
[gw12] [ 76%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-7] 
[gw11] [ 77%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-4] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-8] 
[gw10] [ 77%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-7] 
[gw3] [ 78%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-7] 
[gw2] [ 78%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-7] 
[gw15] [ 79%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-3] 
[gw7] [ 80%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-8] 
[gw15] [ 80%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-3] 
[gw15] [ 81%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-5] 
[gw6] [ 81%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-D-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-5] 
[gw8] [ 82%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-6] 
[gw15] [ 82%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-6] 
[gw6] [ 83%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-5] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-7] 
[gw1] [ 83%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-7] 
[gw15] [ 84%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-6] 
[gw4] [ 85%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-3] 
[gw4] [ 85%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-3] 
[gw8] [ 86%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-6] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-8] 
[gw12] [ 86%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-4] 
[gw0] [ 87%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-3] 
[gw0] [ 87%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-3] 
[gw3] [ 88%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-R-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-7] 
[gw12] [ 88%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-4] 
[gw5] [ 89%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-L-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-8] 
[gw10] [ 90%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-6] 
[gw2] [ 90%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-7] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-8] 
[gw9] [ 91%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-U-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-5] 
[gw14] [ 91%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-D-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-3] 
[gw13] [ 92%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[B<-F-8] 
[gw14] [ 92%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-3] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-3] 
[gw6] [ 93%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-7] 
[gw13] [ 93%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-3] 
[gw1] [ 94%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-7] 
[gw9] [ 95%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-5] 
[gw10] [ 95%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-6] 
[gw11] [ 96%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-F-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-5] 
[gw7] [ 96%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-U-8] 
tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-4] 
[gw7] [ 97%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-4] 
[gw3] [ 97%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-7] 
[gw11] [ 98%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-5] 
[gw8] [ 98%] PASSED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-B-8] 
[gw2] [ 99%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-8] 
[gw5] [100%] FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-8] 

=================================== FAILURES ===================================
__________________ test_communicator_supported_pairs[R<-U-4] ___________________
[gw15] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.U: 'U'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, U -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 1)  (0, 0)      SOURCE:(1, 1)  (0, 0)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 1)  (0, 0)      SOURCE:(0, 1)  (0, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 1)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    3      (0, 1)  (0, 0)      SOURCE:(1, 0)  (0, 0)        (1, 1)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 1)  (0, 1)      SOURCE:(0, 1)  (1, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    1      (1, 1)  (0, 1)      SOURCE:(0, 0)  (1, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (0, 1)    2      (1, 1)  (0, 1)      SOURCE:(1, 0)  (1, 0)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 1)  (0, 1)      SOURCE:(1, 1)  (1, 0)        (1, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 0)  (1, 0)      SOURCE:(1, 0)  (0, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    1      (0, 0)  (1, 0)      SOURCE:(1, 1)  (0, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (1, 0)    2      (0, 0)  (1, 0)      SOURCE:(0, 1)  (0, 1)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 0)  (1, 0)      SOURCE:(0, 0)  (0, 1)        (0, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 0)  (1, 1)      SOURCE:(0, 0)  (1, 1)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 0)  (1, 1)      SOURCE:(1, 0)  (1, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 0)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    3      (1, 0)  (1, 1)      SOURCE:(0, 1)  (1, 1)        (0, 0)     (1, 0)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-U-5] ___________________
[gw0] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.U: 'U'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, U -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 2)  (0, 0)      SOURCE:(2, 2)  (0, 0)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 2)  (0, 0)      SOURCE:(0, 2)  (0, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 2)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    3      (0, 2)  (0, 0)      SOURCE:(2, 0)  (0, 0)        (2, 2)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 2)  (0, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 2)  (0, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (0, 1)    2      (1, 2)  (0, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 2)  (0, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 2)  (0, 2)      SOURCE:(0, 2)  (2, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    1      (2, 2)  (0, 2)      SOURCE:(0, 0)  (2, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (0, 2)    2      (2, 2)  (0, 2)      SOURCE:(2, 0)  (2, 0)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 2)  (0, 2)      SOURCE:(2, 2)  (2, 0)        (2, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 1)  (1, 0)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    1      (0, 1)  (1, 0)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    2      (0, 1)  (1, 0)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 1)  (1, 0)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 0)  (2, 0)      SOURCE:(2, 0)  (0, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    1      (0, 0)  (2, 0)      SOURCE:(2, 2)  (0, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (2, 0)    2      (0, 0)  (2, 0)      SOURCE:(0, 2)  (0, 2)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 0)  (2, 0)      SOURCE:(0, 0)  (0, 2)        (0, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 0)  (2, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 0)  (2, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 1)    2      (1, 0)  (2, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 0)  (2, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 0)  (2, 2)      SOURCE:(0, 0)  (2, 2)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (2, 0)  (2, 2)      SOURCE:(2, 0)  (2, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (2, 2)    2      (2, 0)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    3      (2, 0)  (2, 2)      SOURCE:(0, 2)  (2, 2)        (0, 0)     (2, 0)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-D-4] ___________________
[gw4] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.D: 'D'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, D -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (1, 0)  (0, 0)      SOURCE:(0, 0)  (1, 1)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    1      (1, 0)  (0, 0)      SOURCE:(1, 0)  (1, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (0, 0)    2      (1, 0)  (0, 0)      SOURCE:(1, 1)  (1, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (1, 0)  (0, 0)      SOURCE:(0, 1)  (1, 1)        (0, 0)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (0, 0)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (0, 0)  (0, 1)      SOURCE:(1, 1)  (0, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 1)    2      (0, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    3      (0, 0)  (0, 1)      SOURCE:(0, 0)  (0, 1)        (0, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (1, 1)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (1, 1)  (1, 0)      SOURCE:(0, 0)  (1, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 0)    2      (1, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    3      (1, 1)  (1, 0)      SOURCE:(1, 1)  (1, 0)        (1, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (0, 1)  (1, 1)      SOURCE:(1, 1)  (0, 0)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    1      (0, 1)  (1, 1)      SOURCE:(0, 1)  (0, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (1, 1)    2      (0, 1)  (1, 1)      SOURCE:(0, 0)  (0, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (0, 1)  (1, 1)      SOURCE:(1, 0)  (0, 0)        (1, 1)     (0, 1)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-U-6] ___________________
[gw0] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.U: 'U'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, U -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 3)  (0, 0)      SOURCE:(3, 3)  (0, 0)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 3)  (0, 0)      SOURCE:(0, 3)  (0, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 3)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    3      (0, 3)  (0, 0)      SOURCE:(3, 0)  (0, 0)        (3, 3)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 3)  (0, 1)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    1      (1, 3)  (0, 1)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (0, 1)    2      (1, 3)  (0, 1)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 3)  (0, 1)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 3)  (0, 2)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    1      (2, 3)  (0, 2)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (0, 2)    2      (2, 3)  (0, 2)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 3)  (0, 2)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 3)  (0, 3)      SOURCE:(0, 3)  (3, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    1      (3, 3)  (0, 3)      SOURCE:(0, 0)  (3, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (0, 3)    2      (3, 3)  (0, 3)      SOURCE:(3, 0)  (3, 0)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 3)  (0, 3)      SOURCE:(3, 3)  (3, 0)        (3, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 2)  (1, 0)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    1      (0, 2)  (1, 0)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (1, 0)    2      (0, 2)  (1, 0)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 2)  (1, 0)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 2)  (1, 1)      SOURCE:(2, 2)  (1, 1)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 2)  (1, 1)      SOURCE:(1, 2)  (1, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 2)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    3      (1, 2)  (1, 1)      SOURCE:(2, 1)  (1, 1)        (2, 2)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 2)  (1, 2)      SOURCE:(1, 2)  (2, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    1      (2, 2)  (1, 2)      SOURCE:(1, 1)  (2, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (1, 2)    2      (2, 2)  (1, 2)      SOURCE:(2, 1)  (2, 1)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 2)  (1, 2)      SOURCE:(2, 2)  (2, 1)        (2, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 2)  (1, 3)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    1      (3, 2)  (1, 3)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 3)    2      (3, 2)  (1, 3)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 2)  (1, 3)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 1)  (2, 0)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    1      (0, 1)  (2, 0)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 0)    2      (0, 1)  (2, 0)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 1)  (2, 0)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 1)  (2, 1)      SOURCE:(2, 1)  (1, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    1      (1, 1)  (2, 1)      SOURCE:(2, 2)  (1, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (2, 1)    2      (1, 1)  (2, 1)      SOURCE:(1, 2)  (1, 2)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 1)  (2, 1)      SOURCE:(1, 1)  (1, 2)        (1, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 1)  (2, 2)      SOURCE:(1, 1)  (2, 2)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (2, 1)  (2, 2)      SOURCE:(2, 1)  (2, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (2, 2)    2      (2, 1)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    3      (2, 1)  (2, 2)      SOURCE:(1, 2)  (2, 2)        (1, 1)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 1)  (2, 3)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    1      (3, 1)  (2, 3)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 3)    2      (3, 1)  (2, 3)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 1)  (2, 3)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 0)  (3, 0)      SOURCE:(3, 0)  (0, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    1      (0, 0)  (3, 0)      SOURCE:(3, 3)  (0, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (3, 0)    2      (0, 0)  (3, 0)      SOURCE:(0, 3)  (0, 3)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 0)  (3, 0)      SOURCE:(0, 0)  (0, 3)        (0, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 0)  (3, 1)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    1      (1, 0)  (3, 1)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 1)    2      (1, 0)  (3, 1)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 0)  (3, 1)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 0)  (3, 2)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    1      (2, 0)  (3, 2)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 2)    2      (2, 0)  (3, 2)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 0)  (3, 2)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 0)  (3, 3)      SOURCE:(0, 0)  (3, 3)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (3, 0)  (3, 3)      SOURCE:(3, 0)  (3, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (3, 3)    2      (3, 0)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    3      (3, 0)  (3, 3)      SOURCE:(0, 3)  (3, 3)        (0, 0)     (3, 0)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-D-5] ___________________
[gw4] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.D: 'D'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, D -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (2, 0)  (0, 0)      SOURCE:(0, 0)  (2, 2)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    1      (2, 0)  (0, 0)      SOURCE:(2, 0)  (2, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (0, 0)    2      (2, 0)  (0, 0)      SOURCE:(2, 2)  (2, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (2, 0)  (0, 0)      SOURCE:(0, 2)  (2, 2)        (0, 0)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 0)  (0, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 0)  (0, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    2      (1, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 0)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (0, 0)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (0, 0)  (0, 2)      SOURCE:(2, 2)  (0, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 2)    2      (0, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    3      (0, 0)  (0, 2)      SOURCE:(0, 0)  (0, 2)        (0, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (2, 1)  (1, 0)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (2, 1)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 0)    2      (2, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    3      (2, 1)  (1, 0)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (0, 1)  (1, 2)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (0, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 2)    2      (0, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    3      (0, 1)  (1, 2)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (2, 2)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (2, 2)  (2, 0)      SOURCE:(0, 0)  (2, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 0)    2      (2, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    3      (2, 2)  (2, 0)      SOURCE:(2, 2)  (2, 0)        (2, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (0, 2)  (2, 2)      SOURCE:(2, 2)  (0, 0)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    1      (0, 2)  (2, 2)      SOURCE:(0, 2)  (0, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (2, 2)    2      (0, 2)  (2, 2)      SOURCE:(0, 0)  (0, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (0, 2)  (2, 2)      SOURCE:(2, 0)  (0, 0)        (2, 2)     (0, 2)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-D-6] ___________________
[gw10] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.D: 'D'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, D -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (3, 0)  (0, 0)      SOURCE:(0, 0)  (3, 3)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    1      (3, 0)  (0, 0)      SOURCE:(3, 0)  (3, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (0, 0)    2      (3, 0)  (0, 0)      SOURCE:(3, 3)  (3, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (3, 0)  (0, 0)      SOURCE:(0, 3)  (3, 3)        (0, 0)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (2, 0)  (0, 1)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (2, 0)  (0, 1)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 1)    2      (2, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    3      (2, 0)  (0, 1)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (1, 0)  (0, 2)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (1, 0)  (0, 2)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 2)    2      (1, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    3      (1, 0)  (0, 2)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (0, 0)  (0, 3)      SOURCE:(3, 0)  (0, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (0, 0)  (0, 3)      SOURCE:(3, 3)  (0, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 3)    2      (0, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    3      (0, 0)  (0, 3)      SOURCE:(0, 0)  (0, 3)        (0, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (3, 1)  (1, 0)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (3, 1)  (1, 0)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 0)    2      (3, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    3      (3, 1)  (1, 0)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (2, 1)  (1, 1)      SOURCE:(1, 1)  (2, 2)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    1      (2, 1)  (1, 1)      SOURCE:(2, 1)  (2, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (1, 1)    2      (2, 1)  (1, 1)      SOURCE:(2, 2)  (2, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (2, 1)  (1, 1)      SOURCE:(1, 2)  (2, 2)        (1, 1)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (1, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (1, 1)  (1, 2)      SOURCE:(2, 2)  (1, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 2)    2      (1, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    3      (1, 1)  (1, 2)      SOURCE:(1, 1)  (1, 2)        (1, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (0, 1)  (1, 3)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (0, 1)  (1, 3)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 3)    2      (0, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    3      (0, 1)  (1, 3)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (3, 2)  (2, 0)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (3, 2)  (2, 0)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 0)    2      (3, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    3      (3, 2)  (2, 0)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (2, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (2, 2)  (2, 1)      SOURCE:(1, 1)  (2, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 1)    2      (2, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    3      (2, 2)  (2, 1)      SOURCE:(2, 2)  (2, 1)        (2, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (1, 2)  (2, 2)      SOURCE:(2, 2)  (1, 1)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    1      (1, 2)  (2, 2)      SOURCE:(1, 2)  (1, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (2, 2)    2      (1, 2)  (2, 2)      SOURCE:(1, 1)  (1, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (1, 2)  (2, 2)      SOURCE:(2, 1)  (1, 1)        (2, 2)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (0, 2)  (2, 3)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (0, 2)  (2, 3)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 3)    2      (0, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    3      (0, 2)  (2, 3)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (3, 3)  (3, 0)      SOURCE:(0, 3)  (3, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (3, 3)  (3, 0)      SOURCE:(0, 0)  (3, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 0)    2      (3, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    3      (3, 3)  (3, 0)      SOURCE:(3, 3)  (3, 0)        (3, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (2, 3)  (3, 1)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (2, 3)  (3, 1)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 1)    2      (2, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    3      (2, 3)  (3, 1)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (1, 3)  (3, 2)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (1, 3)  (3, 2)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 2)    2      (1, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    3      (1, 3)  (3, 2)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (0, 3)  (3, 3)      SOURCE:(3, 3)  (0, 0)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    1      (0, 3)  (3, 3)      SOURCE:(0, 3)  (0, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (3, 3)    2      (0, 3)  (3, 3)      SOURCE:(0, 0)  (0, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (0, 3)  (3, 3)      SOURCE:(3, 0)  (0, 0)        (3, 3)     (0, 3)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-U-8] ___________________
[gw12] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.U: 'U'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, U -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 5)  (0, 0)      SOURCE:(5, 5)  (0, 0)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 5)  (0, 0)      SOURCE:(0, 5)  (0, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 5)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    3      (0, 5)  (0, 0)      SOURCE:(5, 0)  (0, 0)        (5, 5)     (0, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 5)  (0, 1)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    1      (1, 5)  (0, 1)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (0, 1)    2      (1, 5)  (0, 1)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 5)  (0, 1)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 5)  (0, 2)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    1      (2, 5)  (0, 2)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (0, 2)    2      (2, 5)  (0, 2)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 5)  (0, 2)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 5)  (0, 3)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    1      (3, 5)  (0, 3)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (0, 3)    2      (3, 5)  (0, 3)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 5)  (0, 3)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 5)  (0, 4)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    1      (4, 5)  (0, 4)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (0, 4)    2      (4, 5)  (0, 4)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (4, 5)  (0, 4)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (5, 5)  (0, 5)      SOURCE:(0, 5)  (5, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    1      (5, 5)  (0, 5)      SOURCE:(0, 0)  (5, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (0, 5)    2      (5, 5)  (0, 5)      SOURCE:(5, 0)  (5, 0)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    3      (5, 5)  (0, 5)      SOURCE:(5, 5)  (5, 0)        (5, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 4)  (1, 0)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    1      (0, 4)  (1, 0)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (1, 0)    2      (0, 4)  (1, 0)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 4)  (1, 0)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 4)  (1, 1)      SOURCE:(4, 4)  (1, 1)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 4)  (1, 1)      SOURCE:(1, 4)  (1, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 4)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    3      (1, 4)  (1, 1)      SOURCE:(4, 1)  (1, 1)        (4, 4)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 4)  (1, 2)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    1      (2, 4)  (1, 2)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (1, 2)    2      (2, 4)  (1, 2)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 4)  (1, 2)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 4)  (1, 3)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    1      (3, 4)  (1, 3)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 3)    2      (3, 4)  (1, 3)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 4)  (1, 3)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 4)  (1, 4)      SOURCE:(1, 4)  (4, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    1      (4, 4)  (1, 4)      SOURCE:(1, 1)  (4, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (1, 4)    2      (4, 4)  (1, 4)      SOURCE:(4, 1)  (4, 1)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (4, 4)  (1, 4)      SOURCE:(4, 4)  (4, 1)        (4, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (5, 4)  (1, 5)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    1      (5, 4)  (1, 5)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (1, 5)    2      (5, 4)  (1, 5)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    3      (5, 4)  (1, 5)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 3)  (2, 0)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    1      (0, 3)  (2, 0)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (2, 0)    2      (0, 3)  (2, 0)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 3)  (2, 0)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 3)  (2, 1)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    1      (1, 3)  (2, 1)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 1)    2      (1, 3)  (2, 1)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 3)  (2, 1)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 3)  (2, 2)      SOURCE:(3, 3)  (2, 2)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (2, 3)  (2, 2)      SOURCE:(2, 3)  (2, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (2, 2)    2      (2, 3)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    3      (2, 3)  (2, 2)      SOURCE:(3, 2)  (2, 2)        (3, 3)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 3)  (2, 3)      SOURCE:(2, 3)  (3, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    1      (3, 3)  (2, 3)      SOURCE:(2, 2)  (3, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (2, 3)    2      (3, 3)  (2, 3)      SOURCE:(3, 2)  (3, 2)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 3)  (2, 3)      SOURCE:(3, 3)  (3, 2)        (3, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 3)  (2, 4)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    1      (4, 3)  (2, 4)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (2, 4)    2      (4, 3)  (2, 4)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 3)  (2, 4)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (5, 3)  (2, 5)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    1      (5, 3)  (2, 5)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (2, 5)    2      (5, 3)  (2, 5)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    3      (5, 3)  (2, 5)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 2)  (3, 0)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    1      (0, 2)  (3, 0)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 0)    2      (0, 2)  (3, 0)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 2)  (3, 0)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 2)  (3, 1)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    1      (1, 2)  (3, 1)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 1)    2      (1, 2)  (3, 1)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 2)  (3, 1)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 2)  (3, 2)      SOURCE:(3, 2)  (2, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    1      (2, 2)  (3, 2)      SOURCE:(3, 3)  (2, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (3, 2)    2      (2, 2)  (3, 2)      SOURCE:(2, 3)  (2, 3)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 2)  (3, 2)      SOURCE:(2, 2)  (2, 3)        (2, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 2)  (3, 3)      SOURCE:(2, 2)  (3, 3)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (3, 2)  (3, 3)      SOURCE:(3, 2)  (3, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (3, 3)    2      (3, 2)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    3      (3, 2)  (3, 3)      SOURCE:(2, 3)  (3, 3)        (2, 2)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 2)  (3, 4)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    1      (4, 2)  (3, 4)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (3, 4)    2      (4, 2)  (3, 4)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 2)  (3, 4)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (5, 2)  (3, 5)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    1      (5, 2)  (3, 5)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (3, 5)    2      (5, 2)  (3, 5)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    3      (5, 2)  (3, 5)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 1)  (4, 0)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    1      (0, 1)  (4, 0)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 0)    2      (0, 1)  (4, 0)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (0, 1)  (4, 0)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 1)  (4, 1)      SOURCE:(4, 1)  (1, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    1      (1, 1)  (4, 1)      SOURCE:(4, 4)  (1, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (4, 1)    2      (1, 1)  (4, 1)      SOURCE:(1, 4)  (1, 4)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (1, 1)  (4, 1)      SOURCE:(1, 1)  (1, 4)        (1, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 1)  (4, 2)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    1      (2, 1)  (4, 2)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (4, 2)    2      (2, 1)  (4, 2)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 1)  (4, 2)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 1)  (4, 3)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    1      (3, 1)  (4, 3)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (4, 3)    2      (3, 1)  (4, 3)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 1)  (4, 3)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 1)  (4, 4)      SOURCE:(1, 1)  (4, 4)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (4, 1)  (4, 4)      SOURCE:(4, 1)  (4, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (4, 4)    2      (4, 1)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    3      (4, 1)  (4, 4)      SOURCE:(1, 4)  (4, 4)        (1, 1)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (5, 1)  (4, 5)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    1      (5, 1)  (4, 5)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (4, 5)    2      (5, 1)  (4, 5)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    3      (5, 1)  (4, 5)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (0, 0)  (5, 0)      SOURCE:(5, 0)  (0, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    1      (0, 0)  (5, 0)      SOURCE:(5, 5)  (0, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (5, 0)    2      (0, 0)  (5, 0)      SOURCE:(0, 5)  (0, 5)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    3      (0, 0)  (5, 0)      SOURCE:(0, 0)  (0, 5)        (0, 5)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (1, 0)  (5, 1)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    1      (1, 0)  (5, 1)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (5, 1)    2      (1, 0)  (5, 1)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    3      (1, 0)  (5, 1)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (2, 0)  (5, 2)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    1      (2, 0)  (5, 2)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (5, 2)    2      (2, 0)  (5, 2)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    3      (2, 0)  (5, 2)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (3, 0)  (5, 3)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    1      (3, 0)  (5, 3)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (5, 3)    2      (3, 0)  (5, 3)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    3      (3, 0)  (5, 3)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (4, 0)  (5, 4)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    1      (4, 0)  (5, 4)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (5, 4)    2      (4, 0)  (5, 4)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    3      (4, 0)  (5, 4)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (5, 0)  (5, 5)      SOURCE:(0, 0)  (5, 5)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    1      (5, 0)  (5, 5)      SOURCE:(5, 0)  (5, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (5, 5)    2      (5, 0)  (5, 5)      SOURCE:(5, 5)  (5, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    3      (5, 0)  (5, 5)      SOURCE:(0, 5)  (5, 5)        (0, 0)     (5, 0)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-U-7] ___________________
[gw0] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.U: 'U'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, U -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 4)  (0, 0)      SOURCE:(4, 4)  (0, 0)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 4)  (0, 0)      SOURCE:(0, 4)  (0, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 4)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    3      (0, 4)  (0, 0)      SOURCE:(4, 0)  (0, 0)        (4, 4)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 4)  (0, 1)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    1      (1, 4)  (0, 1)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (0, 1)    2      (1, 4)  (0, 1)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 4)  (0, 1)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 4)  (0, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 4)  (0, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (0, 2)    2      (2, 4)  (0, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 4)  (0, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 4)  (0, 3)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    1      (3, 4)  (0, 3)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (0, 3)    2      (3, 4)  (0, 3)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 4)  (0, 3)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 4)  (0, 4)      SOURCE:(0, 4)  (4, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    1      (4, 4)  (0, 4)      SOURCE:(0, 0)  (4, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (0, 4)    2      (4, 4)  (0, 4)      SOURCE:(4, 0)  (4, 0)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (4, 4)  (0, 4)      SOURCE:(4, 4)  (4, 0)        (4, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 3)  (1, 0)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    1      (0, 3)  (1, 0)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (1, 0)    2      (0, 3)  (1, 0)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 3)  (1, 0)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 3)  (1, 1)      SOURCE:(3, 3)  (1, 1)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 3)  (1, 1)      SOURCE:(1, 3)  (1, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 3)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    3      (1, 3)  (1, 1)      SOURCE:(3, 1)  (1, 1)        (3, 3)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 3)  (1, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 3)  (1, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 2)    2      (2, 3)  (1, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 3)  (1, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 3)  (1, 3)      SOURCE:(1, 3)  (3, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    1      (3, 3)  (1, 3)      SOURCE:(1, 1)  (3, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (1, 3)    2      (3, 3)  (1, 3)      SOURCE:(3, 1)  (3, 1)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 3)  (1, 3)      SOURCE:(3, 3)  (3, 1)        (3, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 3)  (1, 4)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    1      (4, 3)  (1, 4)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 4)    2      (4, 3)  (1, 4)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (4, 3)  (1, 4)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 2)  (2, 0)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    1      (0, 2)  (2, 0)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    2      (0, 2)  (2, 0)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 2)  (2, 0)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 2)  (2, 3)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    1      (3, 2)  (2, 3)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    2      (3, 2)  (2, 3)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 2)  (2, 3)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 2)  (2, 4)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    1      (4, 2)  (2, 4)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 4)    2      (4, 2)  (2, 4)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 2)  (2, 4)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 1)  (3, 0)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    1      (0, 1)  (3, 0)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 0)    2      (0, 1)  (3, 0)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 1)  (3, 0)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 1)  (3, 1)      SOURCE:(3, 1)  (1, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    1      (1, 1)  (3, 1)      SOURCE:(3, 3)  (1, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (3, 1)    2      (1, 1)  (3, 1)      SOURCE:(1, 3)  (1, 3)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 1)  (3, 1)      SOURCE:(1, 1)  (1, 3)        (1, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 1)  (3, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 1)  (3, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 2)    2      (2, 1)  (3, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 1)  (3, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 1)  (3, 3)      SOURCE:(1, 1)  (3, 3)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (3, 1)  (3, 3)      SOURCE:(3, 1)  (3, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (3, 3)    2      (3, 1)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    3      (3, 1)  (3, 3)      SOURCE:(1, 3)  (3, 3)        (1, 1)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 1)  (3, 4)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    1      (4, 1)  (3, 4)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (3, 4)    2      (4, 1)  (3, 4)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 1)  (3, 4)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 0)  (4, 0)      SOURCE:(4, 0)  (0, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    1      (0, 0)  (4, 0)      SOURCE:(4, 4)  (0, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (4, 0)    2      (0, 0)  (4, 0)      SOURCE:(0, 4)  (0, 4)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (0, 0)  (4, 0)      SOURCE:(0, 0)  (0, 4)        (0, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 0)  (4, 1)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    1      (1, 0)  (4, 1)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 1)    2      (1, 0)  (4, 1)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (1, 0)  (4, 1)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 0)  (4, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 0)  (4, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (4, 2)    2      (2, 0)  (4, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 0)  (4, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 0)  (4, 3)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    1      (3, 0)  (4, 3)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (4, 3)    2      (3, 0)  (4, 3)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 0)  (4, 3)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 0)  (4, 4)      SOURCE:(0, 0)  (4, 4)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (4, 0)  (4, 4)      SOURCE:(4, 0)  (4, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (4, 4)    2      (4, 0)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    3      (4, 0)  (4, 4)      SOURCE:(0, 4)  (4, 4)        (0, 0)     (4, 0)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-D-4] ___________________
[gw12] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.D: 'D'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, D -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 1)  (0, 0)      SOURCE:(1, 1)  (0, 0)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 1)  (0, 0)      SOURCE:(0, 1)  (0, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 1)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    3      (0, 1)  (0, 0)      SOURCE:(1, 0)  (0, 0)        (1, 1)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 1)  (0, 1)      SOURCE:(0, 1)  (1, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    1      (1, 1)  (0, 1)      SOURCE:(0, 0)  (1, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (0, 1)    2      (1, 1)  (0, 1)      SOURCE:(1, 0)  (1, 0)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 1)  (0, 1)      SOURCE:(1, 1)  (1, 0)        (1, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 0)  (1, 0)      SOURCE:(1, 0)  (0, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    1      (0, 0)  (1, 0)      SOURCE:(1, 1)  (0, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (1, 0)    2      (0, 0)  (1, 0)      SOURCE:(0, 1)  (0, 1)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 0)  (1, 0)      SOURCE:(0, 0)  (0, 1)        (0, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 0)  (1, 1)      SOURCE:(0, 0)  (1, 1)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 0)  (1, 1)      SOURCE:(1, 0)  (1, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 0)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    3      (1, 0)  (1, 1)      SOURCE:(0, 1)  (1, 1)        (0, 0)     (1, 0)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-U-4] ___________________
[gw9] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.U: 'U'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, U -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (1, 0)  (0, 0)      SOURCE:(0, 0)  (1, 1)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    1      (1, 0)  (0, 0)      SOURCE:(1, 0)  (1, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (0, 0)    2      (1, 0)  (0, 0)      SOURCE:(1, 1)  (1, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (1, 0)  (0, 0)      SOURCE:(0, 1)  (1, 1)        (0, 0)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (0, 0)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (0, 0)  (0, 1)      SOURCE:(1, 1)  (0, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 1)    2      (0, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    3      (0, 0)  (0, 1)      SOURCE:(0, 0)  (0, 1)        (0, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (1, 1)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (1, 1)  (1, 0)      SOURCE:(0, 0)  (1, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 0)    2      (1, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    3      (1, 1)  (1, 0)      SOURCE:(1, 1)  (1, 0)        (1, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (0, 1)  (1, 1)      SOURCE:(1, 1)  (0, 0)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    1      (0, 1)  (1, 1)      SOURCE:(0, 1)  (0, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (1, 1)    2      (0, 1)  (1, 1)      SOURCE:(0, 0)  (0, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (0, 1)  (1, 1)      SOURCE:(1, 0)  (0, 0)        (1, 1)     (0, 1)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-U-5] ___________________
[gw9] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.U: 'U'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, U -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (2, 0)  (0, 0)      SOURCE:(0, 0)  (2, 2)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    1      (2, 0)  (0, 0)      SOURCE:(2, 0)  (2, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (0, 0)    2      (2, 0)  (0, 0)      SOURCE:(2, 2)  (2, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (2, 0)  (0, 0)      SOURCE:(0, 2)  (2, 2)        (0, 0)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 0)  (0, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 0)  (0, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    2      (1, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 0)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (0, 0)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (0, 0)  (0, 2)      SOURCE:(2, 2)  (0, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 2)    2      (0, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    3      (0, 0)  (0, 2)      SOURCE:(0, 0)  (0, 2)        (0, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (2, 1)  (1, 0)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (2, 1)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 0)    2      (2, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    3      (2, 1)  (1, 0)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (0, 1)  (1, 2)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (0, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 2)    2      (0, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    3      (0, 1)  (1, 2)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (2, 2)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (2, 2)  (2, 0)      SOURCE:(0, 0)  (2, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 0)    2      (2, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    3      (2, 2)  (2, 0)      SOURCE:(2, 2)  (2, 0)        (2, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (0, 2)  (2, 2)      SOURCE:(2, 2)  (0, 0)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    1      (0, 2)  (2, 2)      SOURCE:(0, 2)  (0, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (2, 2)    2      (0, 2)  (2, 2)      SOURCE:(0, 0)  (0, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (0, 2)  (2, 2)      SOURCE:(2, 0)  (0, 0)        (2, 2)     (0, 2)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-L-5] ___________________
[gw15] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.L: 'L'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, L -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 2)  (0, 0)      SOURCE:(0, 0)  (2, 2)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    1      (0, 2)  (0, 0)      SOURCE:(2, 0)  (2, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 0)    2      (0, 2)  (0, 0)      SOURCE:(2, 2)  (2, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 2)  (0, 0)      SOURCE:(0, 2)  (2, 2)        (2, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 2)  (0, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 2)  (0, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (0, 1)    2      (1, 2)  (0, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 2)  (0, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 2)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 2)  (0, 2)      SOURCE:(2, 2)  (0, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (0, 2)    2      (2, 2)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    3      (2, 2)  (0, 2)      SOURCE:(0, 0)  (0, 2)        (2, 0)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 1)  (1, 0)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    1      (0, 1)  (1, 0)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    2      (0, 1)  (1, 0)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 1)  (1, 0)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 0)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (0, 0)  (2, 0)      SOURCE:(0, 0)  (2, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (2, 0)    2      (0, 0)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    3      (0, 0)  (2, 0)      SOURCE:(2, 2)  (2, 0)        (0, 2)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 0)  (2, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 0)  (2, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 1)    2      (1, 0)  (2, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 0)  (2, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 0)  (2, 2)      SOURCE:(2, 2)  (0, 0)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    1      (2, 0)  (2, 2)      SOURCE:(0, 2)  (0, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 2)    2      (2, 0)  (2, 2)      SOURCE:(0, 0)  (0, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (2, 0)  (2, 2)      SOURCE:(2, 0)  (0, 0)        (0, 0)     (0, 2)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-D-6] ___________________
[gw12] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.D: 'D'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, D -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 3)  (0, 0)      SOURCE:(3, 3)  (0, 0)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 3)  (0, 0)      SOURCE:(0, 3)  (0, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 3)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    3      (0, 3)  (0, 0)      SOURCE:(3, 0)  (0, 0)        (3, 3)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 3)  (0, 1)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    1      (1, 3)  (0, 1)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (0, 1)    2      (1, 3)  (0, 1)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 3)  (0, 1)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 3)  (0, 2)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    1      (2, 3)  (0, 2)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (0, 2)    2      (2, 3)  (0, 2)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 3)  (0, 2)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 3)  (0, 3)      SOURCE:(0, 3)  (3, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    1      (3, 3)  (0, 3)      SOURCE:(0, 0)  (3, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (0, 3)    2      (3, 3)  (0, 3)      SOURCE:(3, 0)  (3, 0)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 3)  (0, 3)      SOURCE:(3, 3)  (3, 0)        (3, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 2)  (1, 0)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    1      (0, 2)  (1, 0)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (1, 0)    2      (0, 2)  (1, 0)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 2)  (1, 0)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 2)  (1, 1)      SOURCE:(2, 2)  (1, 1)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 2)  (1, 1)      SOURCE:(1, 2)  (1, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 2)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    3      (1, 2)  (1, 1)      SOURCE:(2, 1)  (1, 1)        (2, 2)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 2)  (1, 2)      SOURCE:(1, 2)  (2, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    1      (2, 2)  (1, 2)      SOURCE:(1, 1)  (2, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (1, 2)    2      (2, 2)  (1, 2)      SOURCE:(2, 1)  (2, 1)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 2)  (1, 2)      SOURCE:(2, 2)  (2, 1)        (2, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 2)  (1, 3)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    1      (3, 2)  (1, 3)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 3)    2      (3, 2)  (1, 3)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 2)  (1, 3)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 1)  (2, 0)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    1      (0, 1)  (2, 0)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 0)    2      (0, 1)  (2, 0)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 1)  (2, 0)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 1)  (2, 1)      SOURCE:(2, 1)  (1, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    1      (1, 1)  (2, 1)      SOURCE:(2, 2)  (1, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (2, 1)    2      (1, 1)  (2, 1)      SOURCE:(1, 2)  (1, 2)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 1)  (2, 1)      SOURCE:(1, 1)  (1, 2)        (1, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 1)  (2, 2)      SOURCE:(1, 1)  (2, 2)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (2, 1)  (2, 2)      SOURCE:(2, 1)  (2, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (2, 2)    2      (2, 1)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    3      (2, 1)  (2, 2)      SOURCE:(1, 2)  (2, 2)        (1, 1)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 1)  (2, 3)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    1      (3, 1)  (2, 3)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 3)    2      (3, 1)  (2, 3)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 1)  (2, 3)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 0)  (3, 0)      SOURCE:(3, 0)  (0, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    1      (0, 0)  (3, 0)      SOURCE:(3, 3)  (0, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (3, 0)    2      (0, 0)  (3, 0)      SOURCE:(0, 3)  (0, 3)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 0)  (3, 0)      SOURCE:(0, 0)  (0, 3)        (0, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 0)  (3, 1)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    1      (1, 0)  (3, 1)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 1)    2      (1, 0)  (3, 1)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 0)  (3, 1)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 0)  (3, 2)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    1      (2, 0)  (3, 2)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 2)    2      (2, 0)  (3, 2)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 0)  (3, 2)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 0)  (3, 3)      SOURCE:(0, 0)  (3, 3)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (3, 0)  (3, 3)      SOURCE:(3, 0)  (3, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (3, 3)    2      (3, 0)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    3      (3, 0)  (3, 3)      SOURCE:(0, 3)  (3, 3)        (0, 0)     (3, 0)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-D-7] ___________________
[gw10] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.D: 'D'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, D -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (4, 0)  (0, 0)      SOURCE:(0, 0)  (4, 4)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    1      (4, 0)  (0, 0)      SOURCE:(4, 0)  (4, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (0, 0)    2      (4, 0)  (0, 0)      SOURCE:(4, 4)  (4, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (4, 0)  (0, 0)      SOURCE:(0, 4)  (4, 4)        (0, 0)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (3, 0)  (0, 1)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (3, 0)  (0, 1)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 1)    2      (3, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    3      (3, 0)  (0, 1)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 0)  (0, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 0)  (0, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    2      (2, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 0)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (1, 0)  (0, 3)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (1, 0)  (0, 3)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 3)    2      (1, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    3      (1, 0)  (0, 3)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (0, 0)  (0, 4)      SOURCE:(4, 0)  (0, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (0, 0)  (0, 4)      SOURCE:(4, 4)  (0, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 4)    2      (0, 0)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    3      (0, 0)  (0, 4)      SOURCE:(0, 0)  (0, 4)        (0, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (4, 1)  (1, 0)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (4, 1)  (1, 0)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 0)    2      (4, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    3      (4, 1)  (1, 0)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (3, 1)  (1, 1)      SOURCE:(1, 1)  (3, 3)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    1      (3, 1)  (1, 1)      SOURCE:(3, 1)  (3, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (1, 1)    2      (3, 1)  (1, 1)      SOURCE:(3, 3)  (3, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (3, 1)  (1, 1)      SOURCE:(1, 3)  (3, 3)        (1, 1)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (1, 1)  (1, 3)      SOURCE:(3, 1)  (1, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (1, 1)  (1, 3)      SOURCE:(3, 3)  (1, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 3)    2      (1, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    3      (1, 1)  (1, 3)      SOURCE:(1, 1)  (1, 3)        (1, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (0, 1)  (1, 4)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (0, 1)  (1, 4)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 4)    2      (0, 1)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    3      (0, 1)  (1, 4)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (4, 2)  (2, 0)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (4, 2)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 0)    2      (4, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    3      (4, 2)  (2, 0)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (3, 2)  (2, 1)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (3, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 1)    2      (3, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    3      (3, 2)  (2, 1)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (1, 2)  (2, 3)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (1, 2)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 3)    2      (1, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    3      (1, 2)  (2, 3)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (0, 2)  (2, 4)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (0, 2)  (2, 4)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 4)    2      (0, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    3      (0, 2)  (2, 4)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (4, 3)  (3, 0)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (4, 3)  (3, 0)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 0)    2      (4, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    3      (4, 3)  (3, 0)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (3, 3)  (3, 1)      SOURCE:(1, 3)  (3, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (3, 3)  (3, 1)      SOURCE:(1, 1)  (3, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 1)    2      (3, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    3      (3, 3)  (3, 1)      SOURCE:(3, 3)  (3, 1)        (3, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 3)  (3, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 3)  (3, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    2      (2, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 3)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (1, 3)  (3, 3)      SOURCE:(3, 3)  (1, 1)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    1      (1, 3)  (3, 3)      SOURCE:(1, 3)  (1, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (3, 3)    2      (1, 3)  (3, 3)      SOURCE:(1, 1)  (1, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (1, 3)  (3, 3)      SOURCE:(3, 1)  (1, 1)        (3, 3)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (0, 3)  (3, 4)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (0, 3)  (3, 4)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 4)    2      (0, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    3      (0, 3)  (3, 4)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (4, 4)  (4, 0)      SOURCE:(0, 4)  (4, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (4, 4)  (4, 0)      SOURCE:(0, 0)  (4, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 0)    2      (4, 4)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    3      (4, 4)  (4, 0)      SOURCE:(4, 4)  (4, 0)        (4, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (3, 4)  (4, 1)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (3, 4)  (4, 1)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 1)    2      (3, 4)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    3      (3, 4)  (4, 1)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 4)  (4, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 4)  (4, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 2)    2      (2, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 4)  (4, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (1, 4)  (4, 3)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (1, 4)  (4, 3)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 3)    2      (1, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    3      (1, 4)  (4, 3)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (0, 4)  (4, 4)      SOURCE:(4, 4)  (0, 0)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    1      (0, 4)  (4, 4)      SOURCE:(0, 4)  (0, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (4, 4)    2      (0, 4)  (4, 4)      SOURCE:(0, 0)  (0, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (0, 4)  (4, 4)      SOURCE:(4, 0)  (0, 0)        (4, 4)     (0, 4)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[R<-D-8] ___________________
[gw1] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.D: 'D'>, <FaceName.R: 'R'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, D -> R
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (5, 0)  (0, 0)      SOURCE:(0, 0)  (5, 5)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    1      (5, 0)  (0, 0)      SOURCE:(5, 0)  (5, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (0, 0)    2      (5, 0)  (0, 0)      SOURCE:(5, 5)  (5, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (5, 0)  (0, 0)      SOURCE:(0, 5)  (5, 5)        (0, 0)     (5, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (4, 0)  (0, 1)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (4, 0)  (0, 1)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 1)    2      (4, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    3      (4, 0)  (0, 1)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (3, 0)  (0, 2)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (3, 0)  (0, 2)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 2)    2      (3, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    3      (3, 0)  (0, 2)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (2, 0)  (0, 3)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (2, 0)  (0, 3)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 3)    2      (2, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    3      (2, 0)  (0, 3)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (1, 0)  (0, 4)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (1, 0)  (0, 4)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 4)    2      (1, 0)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    3      (1, 0)  (0, 4)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (0, 0)  (0, 5)      SOURCE:(5, 0)  (0, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    1      (0, 0)  (0, 5)      SOURCE:(5, 5)  (0, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 5)    2      (0, 0)  (0, 5)      SOURCE:(0, 5)  (0, 5)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    3      (0, 0)  (0, 5)      SOURCE:(0, 0)  (0, 5)        (0, 5)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (5, 1)  (1, 0)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (5, 1)  (1, 0)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (1, 0)    2      (5, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    3      (5, 1)  (1, 0)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (4, 1)  (1, 1)      SOURCE:(1, 1)  (4, 4)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    1      (4, 1)  (1, 1)      SOURCE:(4, 1)  (4, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (1, 1)    2      (4, 1)  (1, 1)      SOURCE:(4, 4)  (4, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (4, 1)  (1, 1)      SOURCE:(1, 4)  (4, 4)        (1, 1)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (3, 1)  (1, 2)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (3, 1)  (1, 2)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 2)    2      (3, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    3      (3, 1)  (1, 2)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (2, 1)  (1, 3)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (2, 1)  (1, 3)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 3)    2      (2, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    3      (2, 1)  (1, 3)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (1, 1)  (1, 4)      SOURCE:(4, 1)  (1, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (1, 1)  (1, 4)      SOURCE:(4, 4)  (1, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 4)    2      (1, 1)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    3      (1, 1)  (1, 4)      SOURCE:(1, 1)  (1, 4)        (1, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (0, 1)  (1, 5)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    1      (0, 1)  (1, 5)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 5)    2      (0, 1)  (1, 5)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    3      (0, 1)  (1, 5)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (5, 2)  (2, 0)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (5, 2)  (2, 0)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (2, 0)    2      (5, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    3      (5, 2)  (2, 0)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (4, 2)  (2, 1)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (4, 2)  (2, 1)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 1)    2      (4, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    3      (4, 2)  (2, 1)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (3, 2)  (2, 2)      SOURCE:(2, 2)  (3, 3)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    1      (3, 2)  (2, 2)      SOURCE:(3, 2)  (3, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (2, 2)    2      (3, 2)  (2, 2)      SOURCE:(3, 3)  (3, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (3, 2)  (2, 2)      SOURCE:(2, 3)  (3, 3)        (2, 2)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (2, 2)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (2, 2)  (2, 3)      SOURCE:(3, 3)  (2, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 3)    2      (2, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    3      (2, 2)  (2, 3)      SOURCE:(2, 2)  (2, 3)        (2, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (1, 2)  (2, 4)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (1, 2)  (2, 4)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 4)    2      (1, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    3      (1, 2)  (2, 4)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (0, 2)  (2, 5)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    1      (0, 2)  (2, 5)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 5)    2      (0, 2)  (2, 5)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    3      (0, 2)  (2, 5)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (5, 3)  (3, 0)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (5, 3)  (3, 0)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (3, 0)    2      (5, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    3      (5, 3)  (3, 0)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (4, 3)  (3, 1)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (4, 3)  (3, 1)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 1)    2      (4, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    3      (4, 3)  (3, 1)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (3, 3)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (3, 3)  (3, 2)      SOURCE:(2, 2)  (3, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 2)    2      (3, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    3      (3, 3)  (3, 2)      SOURCE:(3, 3)  (3, 2)        (3, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (2, 3)  (3, 3)      SOURCE:(3, 3)  (2, 2)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    1      (2, 3)  (3, 3)      SOURCE:(2, 3)  (2, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (3, 3)    2      (2, 3)  (3, 3)      SOURCE:(2, 2)  (2, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (2, 3)  (3, 3)      SOURCE:(3, 2)  (2, 2)        (3, 3)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (1, 3)  (3, 4)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (1, 3)  (3, 4)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 4)    2      (1, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    3      (1, 3)  (3, 4)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (0, 3)  (3, 5)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    1      (0, 3)  (3, 5)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 5)    2      (0, 3)  (3, 5)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    3      (0, 3)  (3, 5)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (5, 4)  (4, 0)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (5, 4)  (4, 0)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (4, 0)    2      (5, 4)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    3      (5, 4)  (4, 0)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (4, 4)  (4, 1)      SOURCE:(1, 4)  (4, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (4, 4)  (4, 1)      SOURCE:(1, 1)  (4, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 1)    2      (4, 4)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    3      (4, 4)  (4, 1)      SOURCE:(4, 4)  (4, 1)        (4, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (3, 4)  (4, 2)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (3, 4)  (4, 2)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 2)    2      (3, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    3      (3, 4)  (4, 2)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (2, 4)  (4, 3)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (2, 4)  (4, 3)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 3)    2      (2, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    3      (2, 4)  (4, 3)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (1, 4)  (4, 4)      SOURCE:(4, 4)  (1, 1)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    1      (1, 4)  (4, 4)      SOURCE:(1, 4)  (1, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (4, 4)    2      (1, 4)  (4, 4)      SOURCE:(1, 1)  (1, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (1, 4)  (4, 4)      SOURCE:(4, 1)  (1, 1)        (4, 4)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (0, 4)  (4, 5)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    1      (0, 4)  (4, 5)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 5)    2      (0, 4)  (4, 5)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    3      (0, 4)  (4, 5)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (5, 5)  (5, 0)      SOURCE:(0, 5)  (5, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    1      (5, 5)  (5, 0)      SOURCE:(0, 0)  (5, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (5, 0)    2      (5, 5)  (5, 0)      SOURCE:(5, 0)  (5, 0)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    3      (5, 5)  (5, 0)      SOURCE:(5, 5)  (5, 0)        (5, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (4, 5)  (5, 1)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    1      (4, 5)  (5, 1)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (5, 1)    2      (4, 5)  (5, 1)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    3      (4, 5)  (5, 1)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (3, 5)  (5, 2)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    1      (3, 5)  (5, 2)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (5, 2)    2      (3, 5)  (5, 2)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    3      (3, 5)  (5, 2)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (2, 5)  (5, 3)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    1      (2, 5)  (5, 3)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (5, 3)    2      (2, 5)  (5, 3)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    3      (2, 5)  (5, 3)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (1, 5)  (5, 4)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    1      (1, 5)  (5, 4)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (5, 4)    2      (1, 5)  (5, 4)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    3      (1, 5)  (5, 4)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (0, 5)  (5, 5)      SOURCE:(5, 5)  (0, 0)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    1      (0, 5)  (5, 5)      SOURCE:(0, 5)  (0, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (5, 5)    2      (0, 5)  (5, 5)      SOURCE:(0, 0)  (0, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    3      (0, 5)  (5, 5)      SOURCE:(5, 0)  (0, 0)        (5, 5)     (0, 5)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-L-6] ___________________
[gw15] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.L: 'L'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, L -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 3)  (0, 0)      SOURCE:(0, 0)  (3, 3)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    1      (0, 3)  (0, 0)      SOURCE:(3, 0)  (3, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 0)    2      (0, 3)  (0, 0)      SOURCE:(3, 3)  (3, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 3)  (0, 0)      SOURCE:(0, 3)  (3, 3)        (3, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 3)  (0, 1)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    1      (1, 3)  (0, 1)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (0, 1)    2      (1, 3)  (0, 1)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 3)  (0, 1)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 3)  (0, 2)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    1      (2, 3)  (0, 2)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (0, 2)    2      (2, 3)  (0, 2)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 3)  (0, 2)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 3)  (0, 3)      SOURCE:(3, 0)  (0, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (3, 3)  (0, 3)      SOURCE:(3, 3)  (0, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (0, 3)    2      (3, 3)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    3      (3, 3)  (0, 3)      SOURCE:(0, 0)  (0, 3)        (3, 0)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 2)  (1, 0)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    1      (0, 2)  (1, 0)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (1, 0)    2      (0, 2)  (1, 0)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 2)  (1, 0)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 2)  (1, 1)      SOURCE:(1, 1)  (2, 2)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    1      (1, 2)  (1, 1)      SOURCE:(2, 1)  (2, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 1)    2      (1, 2)  (1, 1)      SOURCE:(2, 2)  (2, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 2)  (1, 1)      SOURCE:(1, 2)  (2, 2)        (2, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 2)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 2)  (1, 2)      SOURCE:(2, 2)  (1, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 2)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    3      (2, 2)  (1, 2)      SOURCE:(1, 1)  (1, 2)        (2, 1)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 2)  (1, 3)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    1      (3, 2)  (1, 3)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 3)    2      (3, 2)  (1, 3)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 2)  (1, 3)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 1)  (2, 0)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    1      (0, 1)  (2, 0)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 0)    2      (0, 1)  (2, 0)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 1)  (2, 0)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 1)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 1)  (2, 1)      SOURCE:(1, 1)  (2, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 1)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    3      (1, 1)  (2, 1)      SOURCE:(2, 2)  (2, 1)        (1, 2)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 1)  (2, 2)      SOURCE:(2, 2)  (1, 1)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    1      (2, 1)  (2, 2)      SOURCE:(1, 2)  (1, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 2)    2      (2, 1)  (2, 2)      SOURCE:(1, 1)  (1, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (2, 1)  (2, 2)      SOURCE:(2, 1)  (1, 1)        (1, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 1)  (2, 3)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    1      (3, 1)  (2, 3)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 3)    2      (3, 1)  (2, 3)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 1)  (2, 3)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 0)  (3, 0)      SOURCE:(0, 3)  (3, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (0, 0)  (3, 0)      SOURCE:(0, 0)  (3, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (3, 0)    2      (0, 0)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    3      (0, 0)  (3, 0)      SOURCE:(3, 3)  (3, 0)        (0, 3)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 0)  (3, 1)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    1      (1, 0)  (3, 1)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 1)    2      (1, 0)  (3, 1)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 0)  (3, 1)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 0)  (3, 2)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    1      (2, 0)  (3, 2)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 2)    2      (2, 0)  (3, 2)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 0)  (3, 2)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 0)  (3, 3)      SOURCE:(3, 3)  (0, 0)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    1      (3, 0)  (3, 3)      SOURCE:(0, 3)  (0, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 3)    2      (3, 0)  (3, 3)      SOURCE:(0, 0)  (0, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (3, 0)  (3, 3)      SOURCE:(3, 0)  (0, 0)        (0, 0)     (0, 3)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-D-5] ___________________
[gw4] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.D: 'D'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, D -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 2)  (0, 0)      SOURCE:(2, 2)  (0, 0)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 2)  (0, 0)      SOURCE:(0, 2)  (0, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 2)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    3      (0, 2)  (0, 0)      SOURCE:(2, 0)  (0, 0)        (2, 2)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 2)  (0, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 2)  (0, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (0, 1)    2      (1, 2)  (0, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 2)  (0, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 2)  (0, 2)      SOURCE:(0, 2)  (2, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    1      (2, 2)  (0, 2)      SOURCE:(0, 0)  (2, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (0, 2)    2      (2, 2)  (0, 2)      SOURCE:(2, 0)  (2, 0)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 2)  (0, 2)      SOURCE:(2, 2)  (2, 0)        (2, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 1)  (1, 0)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    1      (0, 1)  (1, 0)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    2      (0, 1)  (1, 0)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 1)  (1, 0)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 0)  (2, 0)      SOURCE:(2, 0)  (0, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    1      (0, 0)  (2, 0)      SOURCE:(2, 2)  (0, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (2, 0)    2      (0, 0)  (2, 0)      SOURCE:(0, 2)  (0, 2)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 0)  (2, 0)      SOURCE:(0, 0)  (0, 2)        (0, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 0)  (2, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 0)  (2, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 1)    2      (1, 0)  (2, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 0)  (2, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 0)  (2, 2)      SOURCE:(0, 0)  (2, 2)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (2, 0)  (2, 2)      SOURCE:(2, 0)  (2, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (2, 2)    2      (2, 0)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    3      (2, 0)  (2, 2)      SOURCE:(0, 2)  (2, 2)        (0, 0)     (2, 0)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-U-6] ___________________
[gw14] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.U: 'U'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, U -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (3, 0)  (0, 0)      SOURCE:(0, 0)  (3, 3)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    1      (3, 0)  (0, 0)      SOURCE:(3, 0)  (3, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (0, 0)    2      (3, 0)  (0, 0)      SOURCE:(3, 3)  (3, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (3, 0)  (0, 0)      SOURCE:(0, 3)  (3, 3)        (0, 0)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (2, 0)  (0, 1)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (2, 0)  (0, 1)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 1)    2      (2, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    3      (2, 0)  (0, 1)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (1, 0)  (0, 2)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (1, 0)  (0, 2)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 2)    2      (1, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    3      (1, 0)  (0, 2)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (0, 0)  (0, 3)      SOURCE:(3, 0)  (0, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (0, 0)  (0, 3)      SOURCE:(3, 3)  (0, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 3)    2      (0, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    3      (0, 0)  (0, 3)      SOURCE:(0, 0)  (0, 3)        (0, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (3, 1)  (1, 0)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (3, 1)  (1, 0)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 0)    2      (3, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    3      (3, 1)  (1, 0)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (2, 1)  (1, 1)      SOURCE:(1, 1)  (2, 2)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    1      (2, 1)  (1, 1)      SOURCE:(2, 1)  (2, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (1, 1)    2      (2, 1)  (1, 1)      SOURCE:(2, 2)  (2, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (2, 1)  (1, 1)      SOURCE:(1, 2)  (2, 2)        (1, 1)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (1, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (1, 1)  (1, 2)      SOURCE:(2, 2)  (1, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 2)    2      (1, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    3      (1, 1)  (1, 2)      SOURCE:(1, 1)  (1, 2)        (1, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (0, 1)  (1, 3)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (0, 1)  (1, 3)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 3)    2      (0, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    3      (0, 1)  (1, 3)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (3, 2)  (2, 0)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (3, 2)  (2, 0)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 0)    2      (3, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    3      (3, 2)  (2, 0)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (2, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (2, 2)  (2, 1)      SOURCE:(1, 1)  (2, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 1)    2      (2, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    3      (2, 2)  (2, 1)      SOURCE:(2, 2)  (2, 1)        (2, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (1, 2)  (2, 2)      SOURCE:(2, 2)  (1, 1)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    1      (1, 2)  (2, 2)      SOURCE:(1, 2)  (1, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (2, 2)    2      (1, 2)  (2, 2)      SOURCE:(1, 1)  (1, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (1, 2)  (2, 2)      SOURCE:(2, 1)  (1, 1)        (2, 2)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (0, 2)  (2, 3)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (0, 2)  (2, 3)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 3)    2      (0, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    3      (0, 2)  (2, 3)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (3, 3)  (3, 0)      SOURCE:(0, 3)  (3, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (3, 3)  (3, 0)      SOURCE:(0, 0)  (3, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 0)    2      (3, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    3      (3, 3)  (3, 0)      SOURCE:(3, 3)  (3, 0)        (3, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (2, 3)  (3, 1)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (2, 3)  (3, 1)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 1)    2      (2, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    3      (2, 3)  (3, 1)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (1, 3)  (3, 2)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (1, 3)  (3, 2)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 2)    2      (1, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    3      (1, 3)  (3, 2)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (0, 3)  (3, 3)      SOURCE:(3, 3)  (0, 0)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    1      (0, 3)  (3, 3)      SOURCE:(0, 3)  (0, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (3, 3)    2      (0, 3)  (3, 3)      SOURCE:(0, 0)  (0, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (0, 3)  (3, 3)      SOURCE:(3, 0)  (0, 0)        (3, 3)     (0, 3)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-R-4] ___________________
[gw5] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.R: 'R'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, R -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (1, 0)  (0, 0)      SOURCE:(1, 1)  (0, 0)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (1, 0)  (0, 0)      SOURCE:(0, 1)  (0, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 0)    2      (1, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    3      (1, 0)  (0, 0)      SOURCE:(1, 0)  (0, 0)        (0, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (0, 0)  (0, 1)      SOURCE:(0, 1)  (1, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    1      (0, 0)  (0, 1)      SOURCE:(0, 0)  (1, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (0, 1)    2      (0, 0)  (0, 1)      SOURCE:(1, 0)  (1, 0)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (0, 0)  (0, 1)      SOURCE:(1, 1)  (1, 0)        (0, 1)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (1, 1)  (1, 0)      SOURCE:(1, 0)  (0, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    1      (1, 1)  (1, 0)      SOURCE:(1, 1)  (0, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (1, 0)    2      (1, 1)  (1, 0)      SOURCE:(0, 1)  (0, 1)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (1, 1)  (1, 0)      SOURCE:(0, 0)  (0, 1)        (1, 0)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (0, 1)  (1, 1)      SOURCE:(0, 0)  (1, 1)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (0, 1)  (1, 1)      SOURCE:(1, 0)  (1, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 1)    2      (0, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    3      (0, 1)  (1, 1)      SOURCE:(0, 1)  (1, 1)        (1, 1)     (1, 0)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-D-7] ___________________
[gw12] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.D: 'D'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, D -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 4)  (0, 0)      SOURCE:(4, 4)  (0, 0)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 4)  (0, 0)      SOURCE:(0, 4)  (0, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 4)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    3      (0, 4)  (0, 0)      SOURCE:(4, 0)  (0, 0)        (4, 4)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 4)  (0, 1)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    1      (1, 4)  (0, 1)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (0, 1)    2      (1, 4)  (0, 1)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 4)  (0, 1)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 4)  (0, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 4)  (0, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (0, 2)    2      (2, 4)  (0, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 4)  (0, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 4)  (0, 3)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    1      (3, 4)  (0, 3)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (0, 3)    2      (3, 4)  (0, 3)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 4)  (0, 3)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 4)  (0, 4)      SOURCE:(0, 4)  (4, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    1      (4, 4)  (0, 4)      SOURCE:(0, 0)  (4, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (0, 4)    2      (4, 4)  (0, 4)      SOURCE:(4, 0)  (4, 0)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (4, 4)  (0, 4)      SOURCE:(4, 4)  (4, 0)        (4, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 3)  (1, 0)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    1      (0, 3)  (1, 0)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (1, 0)    2      (0, 3)  (1, 0)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 3)  (1, 0)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 3)  (1, 1)      SOURCE:(3, 3)  (1, 1)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 3)  (1, 1)      SOURCE:(1, 3)  (1, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 3)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    3      (1, 3)  (1, 1)      SOURCE:(3, 1)  (1, 1)        (3, 3)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 3)  (1, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 3)  (1, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 2)    2      (2, 3)  (1, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 3)  (1, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 3)  (1, 3)      SOURCE:(1, 3)  (3, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    1      (3, 3)  (1, 3)      SOURCE:(1, 1)  (3, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (1, 3)    2      (3, 3)  (1, 3)      SOURCE:(3, 1)  (3, 1)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 3)  (1, 3)      SOURCE:(3, 3)  (3, 1)        (3, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 3)  (1, 4)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    1      (4, 3)  (1, 4)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 4)    2      (4, 3)  (1, 4)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (4, 3)  (1, 4)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 2)  (2, 0)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    1      (0, 2)  (2, 0)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    2      (0, 2)  (2, 0)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 2)  (2, 0)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 2)  (2, 3)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    1      (3, 2)  (2, 3)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    2      (3, 2)  (2, 3)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 2)  (2, 3)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 2)  (2, 4)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    1      (4, 2)  (2, 4)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 4)    2      (4, 2)  (2, 4)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 2)  (2, 4)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 1)  (3, 0)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    1      (0, 1)  (3, 0)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 0)    2      (0, 1)  (3, 0)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 1)  (3, 0)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 1)  (3, 1)      SOURCE:(3, 1)  (1, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    1      (1, 1)  (3, 1)      SOURCE:(3, 3)  (1, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (3, 1)    2      (1, 1)  (3, 1)      SOURCE:(1, 3)  (1, 3)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 1)  (3, 1)      SOURCE:(1, 1)  (1, 3)        (1, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 1)  (3, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 1)  (3, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 2)    2      (2, 1)  (3, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 1)  (3, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 1)  (3, 3)      SOURCE:(1, 1)  (3, 3)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (3, 1)  (3, 3)      SOURCE:(3, 1)  (3, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (3, 3)    2      (3, 1)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    3      (3, 1)  (3, 3)      SOURCE:(1, 3)  (3, 3)        (1, 1)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 1)  (3, 4)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    1      (4, 1)  (3, 4)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (3, 4)    2      (4, 1)  (3, 4)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 1)  (3, 4)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 0)  (4, 0)      SOURCE:(4, 0)  (0, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    1      (0, 0)  (4, 0)      SOURCE:(4, 4)  (0, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (4, 0)    2      (0, 0)  (4, 0)      SOURCE:(0, 4)  (0, 4)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (0, 0)  (4, 0)      SOURCE:(0, 0)  (0, 4)        (0, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 0)  (4, 1)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    1      (1, 0)  (4, 1)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 1)    2      (1, 0)  (4, 1)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (1, 0)  (4, 1)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 0)  (4, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 0)  (4, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (4, 2)    2      (2, 0)  (4, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 0)  (4, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 0)  (4, 3)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    1      (3, 0)  (4, 3)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (4, 3)    2      (3, 0)  (4, 3)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 0)  (4, 3)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 0)  (4, 4)      SOURCE:(0, 0)  (4, 4)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (4, 0)  (4, 4)      SOURCE:(4, 0)  (4, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (4, 4)    2      (4, 0)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    3      (4, 0)  (4, 4)      SOURCE:(0, 4)  (4, 4)        (0, 0)     (4, 0)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-L-4] ___________________
[gw3] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.L: 'L'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, L -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 1)  (0, 0)      SOURCE:(0, 0)  (1, 1)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    1      (0, 1)  (0, 0)      SOURCE:(1, 0)  (1, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 0)    2      (0, 1)  (0, 0)      SOURCE:(1, 1)  (1, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 1)  (0, 0)      SOURCE:(0, 1)  (1, 1)        (1, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 1)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 1)  (0, 1)      SOURCE:(1, 1)  (0, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (0, 1)    2      (1, 1)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    3      (1, 1)  (0, 1)      SOURCE:(0, 0)  (0, 1)        (1, 0)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 0)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (0, 0)  (1, 0)      SOURCE:(0, 0)  (1, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (1, 0)    2      (0, 0)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    3      (0, 0)  (1, 0)      SOURCE:(1, 1)  (1, 0)        (0, 1)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 0)  (1, 1)      SOURCE:(1, 1)  (0, 0)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    1      (1, 0)  (1, 1)      SOURCE:(0, 1)  (0, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 1)    2      (1, 0)  (1, 1)      SOURCE:(0, 0)  (0, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 0)  (1, 1)      SOURCE:(1, 0)  (0, 0)        (0, 0)     (0, 1)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-R-5] ___________________
[gw5] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.R: 'R'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, R -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (2, 0)  (0, 0)      SOURCE:(2, 2)  (0, 0)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (2, 0)  (0, 0)      SOURCE:(0, 2)  (0, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 0)    2      (2, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    3      (2, 0)  (0, 0)      SOURCE:(2, 0)  (0, 0)        (0, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 0)  (0, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 0)  (0, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    2      (1, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 0)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (0, 0)  (0, 2)      SOURCE:(0, 2)  (2, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    1      (0, 0)  (0, 2)      SOURCE:(0, 0)  (2, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (0, 2)    2      (0, 0)  (0, 2)      SOURCE:(2, 0)  (2, 0)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (0, 0)  (0, 2)      SOURCE:(2, 2)  (2, 0)        (0, 2)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (2, 1)  (1, 0)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (2, 1)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 0)    2      (2, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    3      (2, 1)  (1, 0)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (0, 1)  (1, 2)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (0, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 2)    2      (0, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    3      (0, 1)  (1, 2)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (2, 2)  (2, 0)      SOURCE:(2, 0)  (0, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    1      (2, 2)  (2, 0)      SOURCE:(2, 2)  (0, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (2, 0)    2      (2, 2)  (2, 0)      SOURCE:(0, 2)  (0, 2)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (2, 2)  (2, 0)      SOURCE:(0, 0)  (0, 2)        (2, 0)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (0, 2)  (2, 2)      SOURCE:(0, 0)  (2, 2)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (0, 2)  (2, 2)      SOURCE:(2, 0)  (2, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 2)    2      (0, 2)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    3      (0, 2)  (2, 2)      SOURCE:(0, 2)  (2, 2)        (2, 2)     (2, 0)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-D-8] ___________________
[gw9] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.D: 'D'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, D -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 5)  (0, 0)      SOURCE:(5, 5)  (0, 0)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (0, 5)  (0, 0)      SOURCE:(0, 5)  (0, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (0, 0)    2      (0, 5)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    3      (0, 5)  (0, 0)      SOURCE:(5, 0)  (0, 0)        (5, 5)     (0, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 5)  (0, 1)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    1      (1, 5)  (0, 1)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (0, 1)    2      (1, 5)  (0, 1)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 5)  (0, 1)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 5)  (0, 2)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    1      (2, 5)  (0, 2)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (0, 2)    2      (2, 5)  (0, 2)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 5)  (0, 2)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 5)  (0, 3)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    1      (3, 5)  (0, 3)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (0, 3)    2      (3, 5)  (0, 3)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 5)  (0, 3)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 5)  (0, 4)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    1      (4, 5)  (0, 4)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (0, 4)    2      (4, 5)  (0, 4)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (4, 5)  (0, 4)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (5, 5)  (0, 5)      SOURCE:(0, 5)  (5, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    1      (5, 5)  (0, 5)      SOURCE:(0, 0)  (5, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (0, 5)    2      (5, 5)  (0, 5)      SOURCE:(5, 0)  (5, 0)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    3      (5, 5)  (0, 5)      SOURCE:(5, 5)  (5, 0)        (5, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 4)  (1, 0)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    1      (0, 4)  (1, 0)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (1, 0)    2      (0, 4)  (1, 0)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 4)  (1, 0)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 4)  (1, 1)      SOURCE:(4, 4)  (1, 1)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (1, 4)  (1, 1)      SOURCE:(1, 4)  (1, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (1, 1)    2      (1, 4)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    3      (1, 4)  (1, 1)      SOURCE:(4, 1)  (1, 1)        (4, 4)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 4)  (1, 2)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    1      (2, 4)  (1, 2)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (1, 2)    2      (2, 4)  (1, 2)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 4)  (1, 2)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 4)  (1, 3)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    1      (3, 4)  (1, 3)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 3)    2      (3, 4)  (1, 3)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 4)  (1, 3)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 4)  (1, 4)      SOURCE:(1, 4)  (4, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    1      (4, 4)  (1, 4)      SOURCE:(1, 1)  (4, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (1, 4)    2      (4, 4)  (1, 4)      SOURCE:(4, 1)  (4, 1)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (4, 4)  (1, 4)      SOURCE:(4, 4)  (4, 1)        (4, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (5, 4)  (1, 5)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    1      (5, 4)  (1, 5)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (1, 5)    2      (5, 4)  (1, 5)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    3      (5, 4)  (1, 5)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 3)  (2, 0)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    1      (0, 3)  (2, 0)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (2, 0)    2      (0, 3)  (2, 0)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 3)  (2, 0)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 3)  (2, 1)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    1      (1, 3)  (2, 1)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 1)    2      (1, 3)  (2, 1)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 3)  (2, 1)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 3)  (2, 2)      SOURCE:(3, 3)  (2, 2)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (2, 3)  (2, 2)      SOURCE:(2, 3)  (2, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (2, 2)    2      (2, 3)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    3      (2, 3)  (2, 2)      SOURCE:(3, 2)  (2, 2)        (3, 3)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 3)  (2, 3)      SOURCE:(2, 3)  (3, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    1      (3, 3)  (2, 3)      SOURCE:(2, 2)  (3, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (2, 3)    2      (3, 3)  (2, 3)      SOURCE:(3, 2)  (3, 2)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 3)  (2, 3)      SOURCE:(3, 3)  (3, 2)        (3, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 3)  (2, 4)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    1      (4, 3)  (2, 4)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (2, 4)    2      (4, 3)  (2, 4)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 3)  (2, 4)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (5, 3)  (2, 5)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    1      (5, 3)  (2, 5)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (2, 5)    2      (5, 3)  (2, 5)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    3      (5, 3)  (2, 5)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 2)  (3, 0)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    1      (0, 2)  (3, 0)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 0)    2      (0, 2)  (3, 0)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 2)  (3, 0)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 2)  (3, 1)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    1      (1, 2)  (3, 1)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 1)    2      (1, 2)  (3, 1)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 2)  (3, 1)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 2)  (3, 2)      SOURCE:(3, 2)  (2, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    1      (2, 2)  (3, 2)      SOURCE:(3, 3)  (2, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (3, 2)    2      (2, 2)  (3, 2)      SOURCE:(2, 3)  (2, 3)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 2)  (3, 2)      SOURCE:(2, 2)  (2, 3)        (2, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 2)  (3, 3)      SOURCE:(2, 2)  (3, 3)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (3, 2)  (3, 3)      SOURCE:(3, 2)  (3, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (3, 3)    2      (3, 2)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    3      (3, 2)  (3, 3)      SOURCE:(2, 3)  (3, 3)        (2, 2)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 2)  (3, 4)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    1      (4, 2)  (3, 4)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (3, 4)    2      (4, 2)  (3, 4)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 2)  (3, 4)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (5, 2)  (3, 5)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    1      (5, 2)  (3, 5)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (3, 5)    2      (5, 2)  (3, 5)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    3      (5, 2)  (3, 5)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 1)  (4, 0)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    1      (0, 1)  (4, 0)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 0)    2      (0, 1)  (4, 0)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (0, 1)  (4, 0)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 1)  (4, 1)      SOURCE:(4, 1)  (1, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    1      (1, 1)  (4, 1)      SOURCE:(4, 4)  (1, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (4, 1)    2      (1, 1)  (4, 1)      SOURCE:(1, 4)  (1, 4)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (1, 1)  (4, 1)      SOURCE:(1, 1)  (1, 4)        (1, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 1)  (4, 2)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    1      (2, 1)  (4, 2)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (4, 2)    2      (2, 1)  (4, 2)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 1)  (4, 2)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 1)  (4, 3)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    1      (3, 1)  (4, 3)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (4, 3)    2      (3, 1)  (4, 3)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 1)  (4, 3)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 1)  (4, 4)      SOURCE:(1, 1)  (4, 4)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (4, 1)  (4, 4)      SOURCE:(4, 1)  (4, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (4, 4)    2      (4, 1)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    3      (4, 1)  (4, 4)      SOURCE:(1, 4)  (4, 4)        (1, 1)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (5, 1)  (4, 5)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    1      (5, 1)  (4, 5)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (4, 5)    2      (5, 1)  (4, 5)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    3      (5, 1)  (4, 5)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (0, 0)  (5, 0)      SOURCE:(5, 0)  (0, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    1      (0, 0)  (5, 0)      SOURCE:(5, 5)  (0, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (5, 0)    2      (0, 0)  (5, 0)      SOURCE:(0, 5)  (0, 5)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    3      (0, 0)  (5, 0)      SOURCE:(0, 0)  (0, 5)        (0, 5)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (1, 0)  (5, 1)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    1      (1, 0)  (5, 1)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (5, 1)    2      (1, 0)  (5, 1)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    3      (1, 0)  (5, 1)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (2, 0)  (5, 2)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    1      (2, 0)  (5, 2)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (5, 2)    2      (2, 0)  (5, 2)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    3      (2, 0)  (5, 2)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (3, 0)  (5, 3)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    1      (3, 0)  (5, 3)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (5, 3)    2      (3, 0)  (5, 3)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    3      (3, 0)  (5, 3)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (4, 0)  (5, 4)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    1      (4, 0)  (5, 4)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (5, 4)    2      (4, 0)  (5, 4)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    3      (4, 0)  (5, 4)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (5, 0)  (5, 5)      SOURCE:(0, 0)  (5, 5)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    1      (5, 0)  (5, 5)      SOURCE:(5, 0)  (5, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (5, 5)    2      (5, 0)  (5, 5)      SOURCE:(5, 5)  (5, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    3      (5, 0)  (5, 5)      SOURCE:(0, 5)  (5, 5)        (0, 0)     (5, 0)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-R-7] ___________________
[gw4] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.R: 'R'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, R -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (4, 0)  (0, 0)      SOURCE:(4, 4)  (0, 0)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (4, 0)  (0, 0)      SOURCE:(0, 4)  (0, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 0)    2      (4, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    3      (4, 0)  (0, 0)      SOURCE:(4, 0)  (0, 0)        (0, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (3, 0)  (0, 1)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (3, 0)  (0, 1)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 1)    2      (3, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    3      (3, 0)  (0, 1)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 0)  (0, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 0)  (0, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    2      (2, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 0)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (1, 0)  (0, 3)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (1, 0)  (0, 3)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 3)    2      (1, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    3      (1, 0)  (0, 3)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (0, 0)  (0, 4)      SOURCE:(0, 4)  (4, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    1      (0, 0)  (0, 4)      SOURCE:(0, 0)  (4, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (0, 4)    2      (0, 0)  (0, 4)      SOURCE:(4, 0)  (4, 0)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (0, 0)  (0, 4)      SOURCE:(4, 4)  (4, 0)        (0, 4)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (4, 1)  (1, 0)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (4, 1)  (1, 0)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 0)    2      (4, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    3      (4, 1)  (1, 0)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (3, 1)  (1, 1)      SOURCE:(3, 3)  (1, 1)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (3, 1)  (1, 1)      SOURCE:(1, 3)  (1, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 1)    2      (3, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    3      (3, 1)  (1, 1)      SOURCE:(3, 1)  (1, 1)        (1, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (1, 1)  (1, 3)      SOURCE:(1, 3)  (3, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    1      (1, 1)  (1, 3)      SOURCE:(1, 1)  (3, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (1, 3)    2      (1, 1)  (1, 3)      SOURCE:(3, 1)  (3, 1)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (1, 1)  (1, 3)      SOURCE:(3, 3)  (3, 1)        (1, 3)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (0, 1)  (1, 4)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (0, 1)  (1, 4)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 4)    2      (0, 1)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    3      (0, 1)  (1, 4)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (4, 2)  (2, 0)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (4, 2)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 0)    2      (4, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    3      (4, 2)  (2, 0)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (3, 2)  (2, 1)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (3, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 1)    2      (3, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    3      (3, 2)  (2, 1)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (1, 2)  (2, 3)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (1, 2)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 3)    2      (1, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    3      (1, 2)  (2, 3)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (0, 2)  (2, 4)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (0, 2)  (2, 4)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 4)    2      (0, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    3      (0, 2)  (2, 4)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (4, 3)  (3, 0)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (4, 3)  (3, 0)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 0)    2      (4, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    3      (4, 3)  (3, 0)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (3, 3)  (3, 1)      SOURCE:(3, 1)  (1, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    1      (3, 3)  (3, 1)      SOURCE:(3, 3)  (1, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (3, 1)    2      (3, 3)  (3, 1)      SOURCE:(1, 3)  (1, 3)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (3, 3)  (3, 1)      SOURCE:(1, 1)  (1, 3)        (3, 1)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 3)  (3, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 3)  (3, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    2      (2, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 3)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (1, 3)  (3, 3)      SOURCE:(1, 1)  (3, 3)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (1, 3)  (3, 3)      SOURCE:(3, 1)  (3, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 3)    2      (1, 3)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    3      (1, 3)  (3, 3)      SOURCE:(1, 3)  (3, 3)        (3, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (0, 3)  (3, 4)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (0, 3)  (3, 4)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 4)    2      (0, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    3      (0, 3)  (3, 4)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (4, 4)  (4, 0)      SOURCE:(4, 0)  (0, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    1      (4, 4)  (4, 0)      SOURCE:(4, 4)  (0, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (4, 0)    2      (4, 4)  (4, 0)      SOURCE:(0, 4)  (0, 4)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (4, 4)  (4, 0)      SOURCE:(0, 0)  (0, 4)        (4, 0)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (3, 4)  (4, 1)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (3, 4)  (4, 1)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 1)    2      (3, 4)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    3      (3, 4)  (4, 1)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 4)  (4, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 4)  (4, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 2)    2      (2, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 4)  (4, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (1, 4)  (4, 3)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (1, 4)  (4, 3)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 3)    2      (1, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    3      (1, 4)  (4, 3)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (0, 4)  (4, 4)      SOURCE:(0, 0)  (4, 4)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (0, 4)  (4, 4)      SOURCE:(4, 0)  (4, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 4)    2      (0, 4)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    3      (0, 4)  (4, 4)      SOURCE:(0, 4)  (4, 4)        (4, 4)     (4, 0)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-R-6] ___________________
[gw15] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.R: 'R'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, R -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (3, 0)  (0, 0)      SOURCE:(3, 3)  (0, 0)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (3, 0)  (0, 0)      SOURCE:(0, 3)  (0, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 0)    2      (3, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    3      (3, 0)  (0, 0)      SOURCE:(3, 0)  (0, 0)        (0, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (2, 0)  (0, 1)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (2, 0)  (0, 1)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 1)    2      (2, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    3      (2, 0)  (0, 1)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (1, 0)  (0, 2)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (1, 0)  (0, 2)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 2)    2      (1, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    3      (1, 0)  (0, 2)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (0, 0)  (0, 3)      SOURCE:(0, 3)  (3, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    1      (0, 0)  (0, 3)      SOURCE:(0, 0)  (3, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (0, 3)    2      (0, 0)  (0, 3)      SOURCE:(3, 0)  (3, 0)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (0, 0)  (0, 3)      SOURCE:(3, 3)  (3, 0)        (0, 3)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (3, 1)  (1, 0)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (3, 1)  (1, 0)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 0)    2      (3, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    3      (3, 1)  (1, 0)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (2, 1)  (1, 1)      SOURCE:(2, 2)  (1, 1)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (2, 1)  (1, 1)      SOURCE:(1, 2)  (1, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 1)    2      (2, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    3      (2, 1)  (1, 1)      SOURCE:(2, 1)  (1, 1)        (1, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (1, 1)  (1, 2)      SOURCE:(1, 2)  (2, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    1      (1, 1)  (1, 2)      SOURCE:(1, 1)  (2, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (1, 2)    2      (1, 1)  (1, 2)      SOURCE:(2, 1)  (2, 1)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (1, 1)  (1, 2)      SOURCE:(2, 2)  (2, 1)        (1, 2)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (0, 1)  (1, 3)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (0, 1)  (1, 3)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 3)    2      (0, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    3      (0, 1)  (1, 3)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (3, 2)  (2, 0)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (3, 2)  (2, 0)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 0)    2      (3, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    3      (3, 2)  (2, 0)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (2, 2)  (2, 1)      SOURCE:(2, 1)  (1, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    1      (2, 2)  (2, 1)      SOURCE:(2, 2)  (1, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (2, 1)    2      (2, 2)  (2, 1)      SOURCE:(1, 2)  (1, 2)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (2, 2)  (2, 1)      SOURCE:(1, 1)  (1, 2)        (2, 1)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (1, 2)  (2, 2)      SOURCE:(1, 1)  (2, 2)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (1, 2)  (2, 2)      SOURCE:(2, 1)  (2, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 2)    2      (1, 2)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    3      (1, 2)  (2, 2)      SOURCE:(1, 2)  (2, 2)        (2, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (0, 2)  (2, 3)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (0, 2)  (2, 3)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 3)    2      (0, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    3      (0, 2)  (2, 3)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (3, 3)  (3, 0)      SOURCE:(3, 0)  (0, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    1      (3, 3)  (3, 0)      SOURCE:(3, 3)  (0, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (3, 0)    2      (3, 3)  (3, 0)      SOURCE:(0, 3)  (0, 3)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (3, 3)  (3, 0)      SOURCE:(0, 0)  (0, 3)        (3, 0)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (2, 3)  (3, 1)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (2, 3)  (3, 1)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 1)    2      (2, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    3      (2, 3)  (3, 1)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (1, 3)  (3, 2)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (1, 3)  (3, 2)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 2)    2      (1, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    3      (1, 3)  (3, 2)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (0, 3)  (3, 3)      SOURCE:(0, 0)  (3, 3)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (0, 3)  (3, 3)      SOURCE:(3, 0)  (3, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 3)    2      (0, 3)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    3      (0, 3)  (3, 3)      SOURCE:(0, 3)  (3, 3)        (3, 3)     (3, 0)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-L-8] ___________________
[gw13] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.L: 'L'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, L -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 5)  (0, 0)      SOURCE:(0, 0)  (5, 5)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    1      (0, 5)  (0, 0)      SOURCE:(5, 0)  (5, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (0, 0)    2      (0, 5)  (0, 0)      SOURCE:(5, 5)  (5, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 5)  (0, 0)      SOURCE:(0, 5)  (5, 5)        (5, 5)     (5, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 5)  (0, 1)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    1      (1, 5)  (0, 1)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (0, 1)    2      (1, 5)  (0, 1)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 5)  (0, 1)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 5)  (0, 2)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    1      (2, 5)  (0, 2)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (0, 2)    2      (2, 5)  (0, 2)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 5)  (0, 2)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 5)  (0, 3)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    1      (3, 5)  (0, 3)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (0, 3)    2      (3, 5)  (0, 3)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 5)  (0, 3)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 5)  (0, 4)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    1      (4, 5)  (0, 4)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (0, 4)    2      (4, 5)  (0, 4)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (4, 5)  (0, 4)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (5, 5)  (0, 5)      SOURCE:(5, 0)  (0, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    1      (5, 5)  (0, 5)      SOURCE:(5, 5)  (0, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (0, 5)    2      (5, 5)  (0, 5)      SOURCE:(0, 5)  (0, 5)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    3      (5, 5)  (0, 5)      SOURCE:(0, 0)  (0, 5)        (5, 0)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 4)  (1, 0)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    1      (0, 4)  (1, 0)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (1, 0)    2      (0, 4)  (1, 0)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 4)  (1, 0)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 4)  (1, 1)      SOURCE:(1, 1)  (4, 4)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    1      (1, 4)  (1, 1)      SOURCE:(4, 1)  (4, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 1)    2      (1, 4)  (1, 1)      SOURCE:(4, 4)  (4, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 4)  (1, 1)      SOURCE:(1, 4)  (4, 4)        (4, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 4)  (1, 2)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    1      (2, 4)  (1, 2)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (1, 2)    2      (2, 4)  (1, 2)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 4)  (1, 2)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 4)  (1, 3)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    1      (3, 4)  (1, 3)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 3)    2      (3, 4)  (1, 3)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 4)  (1, 3)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 4)  (1, 4)      SOURCE:(4, 1)  (1, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (4, 4)  (1, 4)      SOURCE:(4, 4)  (1, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (1, 4)    2      (4, 4)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    3      (4, 4)  (1, 4)      SOURCE:(1, 1)  (1, 4)        (4, 1)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (5, 4)  (1, 5)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    1      (5, 4)  (1, 5)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (1, 5)    2      (5, 4)  (1, 5)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    3      (5, 4)  (1, 5)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 3)  (2, 0)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    1      (0, 3)  (2, 0)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (2, 0)    2      (0, 3)  (2, 0)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 3)  (2, 0)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 3)  (2, 1)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    1      (1, 3)  (2, 1)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 1)    2      (1, 3)  (2, 1)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 3)  (2, 1)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 3)  (2, 2)      SOURCE:(2, 2)  (3, 3)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    1      (2, 3)  (2, 2)      SOURCE:(3, 2)  (3, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 2)    2      (2, 3)  (2, 2)      SOURCE:(3, 3)  (3, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (2, 3)  (2, 2)      SOURCE:(2, 3)  (3, 3)        (3, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 3)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (3, 3)  (2, 3)      SOURCE:(3, 3)  (2, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (2, 3)    2      (3, 3)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    3      (3, 3)  (2, 3)      SOURCE:(2, 2)  (2, 3)        (3, 2)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 3)  (2, 4)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    1      (4, 3)  (2, 4)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (2, 4)    2      (4, 3)  (2, 4)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 3)  (2, 4)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (5, 3)  (2, 5)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    1      (5, 3)  (2, 5)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (2, 5)    2      (5, 3)  (2, 5)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    3      (5, 3)  (2, 5)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 2)  (3, 0)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    1      (0, 2)  (3, 0)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 0)    2      (0, 2)  (3, 0)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 2)  (3, 0)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 2)  (3, 1)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    1      (1, 2)  (3, 1)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 1)    2      (1, 2)  (3, 1)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 2)  (3, 1)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 2)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 2)  (3, 2)      SOURCE:(2, 2)  (3, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (3, 2)    2      (2, 2)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    3      (2, 2)  (3, 2)      SOURCE:(3, 3)  (3, 2)        (2, 3)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 2)  (3, 3)      SOURCE:(3, 3)  (2, 2)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    1      (3, 2)  (3, 3)      SOURCE:(2, 3)  (2, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 3)    2      (3, 2)  (3, 3)      SOURCE:(2, 2)  (2, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (3, 2)  (3, 3)      SOURCE:(3, 2)  (2, 2)        (2, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 2)  (3, 4)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    1      (4, 2)  (3, 4)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (3, 4)    2      (4, 2)  (3, 4)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 2)  (3, 4)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (5, 2)  (3, 5)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    1      (5, 2)  (3, 5)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (3, 5)    2      (5, 2)  (3, 5)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    3      (5, 2)  (3, 5)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 1)  (4, 0)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    1      (0, 1)  (4, 0)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 0)    2      (0, 1)  (4, 0)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (0, 1)  (4, 0)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 1)  (4, 1)      SOURCE:(1, 4)  (4, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (1, 1)  (4, 1)      SOURCE:(1, 1)  (4, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (4, 1)    2      (1, 1)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    3      (1, 1)  (4, 1)      SOURCE:(4, 4)  (4, 1)        (1, 4)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 1)  (4, 2)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    1      (2, 1)  (4, 2)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (4, 2)    2      (2, 1)  (4, 2)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 1)  (4, 2)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 1)  (4, 3)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    1      (3, 1)  (4, 3)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (4, 3)    2      (3, 1)  (4, 3)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 1)  (4, 3)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 1)  (4, 4)      SOURCE:(4, 4)  (1, 1)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    1      (4, 1)  (4, 4)      SOURCE:(1, 4)  (1, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 4)    2      (4, 1)  (4, 4)      SOURCE:(1, 1)  (1, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (4, 1)  (4, 4)      SOURCE:(4, 1)  (1, 1)        (1, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (5, 1)  (4, 5)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    1      (5, 1)  (4, 5)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (4, 5)    2      (5, 1)  (4, 5)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    3      (5, 1)  (4, 5)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (0, 0)  (5, 0)      SOURCE:(0, 5)  (5, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    1      (0, 0)  (5, 0)      SOURCE:(0, 0)  (5, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (5, 0)    2      (0, 0)  (5, 0)      SOURCE:(5, 0)  (5, 0)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    3      (0, 0)  (5, 0)      SOURCE:(5, 5)  (5, 0)        (0, 5)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (1, 0)  (5, 1)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    1      (1, 0)  (5, 1)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (5, 1)    2      (1, 0)  (5, 1)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    3      (1, 0)  (5, 1)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (2, 0)  (5, 2)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    1      (2, 0)  (5, 2)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (5, 2)    2      (2, 0)  (5, 2)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    3      (2, 0)  (5, 2)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (3, 0)  (5, 3)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    1      (3, 0)  (5, 3)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (5, 3)    2      (3, 0)  (5, 3)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    3      (3, 0)  (5, 3)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (4, 0)  (5, 4)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    1      (4, 0)  (5, 4)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (5, 4)    2      (4, 0)  (5, 4)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    3      (4, 0)  (5, 4)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (5, 0)  (5, 5)      SOURCE:(5, 5)  (0, 0)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    1      (5, 0)  (5, 5)      SOURCE:(0, 5)  (0, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (5, 5)    2      (5, 0)  (5, 5)      SOURCE:(0, 0)  (0, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    3      (5, 0)  (5, 5)      SOURCE:(5, 0)  (0, 0)        (0, 0)     (0, 5)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-U-7] ___________________
[gw14] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.U: 'U'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, U -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (4, 0)  (0, 0)      SOURCE:(0, 0)  (4, 4)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    1      (4, 0)  (0, 0)      SOURCE:(4, 0)  (4, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (0, 0)    2      (4, 0)  (0, 0)      SOURCE:(4, 4)  (4, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (4, 0)  (0, 0)      SOURCE:(0, 4)  (4, 4)        (0, 0)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (3, 0)  (0, 1)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (3, 0)  (0, 1)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 1)    2      (3, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    3      (3, 0)  (0, 1)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 0)  (0, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 0)  (0, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    2      (2, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 0)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (1, 0)  (0, 3)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (1, 0)  (0, 3)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 3)    2      (1, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    3      (1, 0)  (0, 3)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (0, 0)  (0, 4)      SOURCE:(4, 0)  (0, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (0, 0)  (0, 4)      SOURCE:(4, 4)  (0, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 4)    2      (0, 0)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    3      (0, 0)  (0, 4)      SOURCE:(0, 0)  (0, 4)        (0, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (4, 1)  (1, 0)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (4, 1)  (1, 0)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 0)    2      (4, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    3      (4, 1)  (1, 0)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (3, 1)  (1, 1)      SOURCE:(1, 1)  (3, 3)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    1      (3, 1)  (1, 1)      SOURCE:(3, 1)  (3, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (1, 1)    2      (3, 1)  (1, 1)      SOURCE:(3, 3)  (3, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (3, 1)  (1, 1)      SOURCE:(1, 3)  (3, 3)        (1, 1)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (1, 1)  (1, 3)      SOURCE:(3, 1)  (1, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (1, 1)  (1, 3)      SOURCE:(3, 3)  (1, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 3)    2      (1, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    3      (1, 1)  (1, 3)      SOURCE:(1, 1)  (1, 3)        (1, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (0, 1)  (1, 4)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (0, 1)  (1, 4)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 4)    2      (0, 1)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    3      (0, 1)  (1, 4)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (4, 2)  (2, 0)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (4, 2)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 0)    2      (4, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    3      (4, 2)  (2, 0)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (3, 2)  (2, 1)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (3, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 1)    2      (3, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    3      (3, 2)  (2, 1)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (1, 2)  (2, 3)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (1, 2)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 3)    2      (1, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    3      (1, 2)  (2, 3)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (0, 2)  (2, 4)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (0, 2)  (2, 4)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 4)    2      (0, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    3      (0, 2)  (2, 4)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (4, 3)  (3, 0)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (4, 3)  (3, 0)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 0)    2      (4, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    3      (4, 3)  (3, 0)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (3, 3)  (3, 1)      SOURCE:(1, 3)  (3, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (3, 3)  (3, 1)      SOURCE:(1, 1)  (3, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 1)    2      (3, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    3      (3, 3)  (3, 1)      SOURCE:(3, 3)  (3, 1)        (3, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 3)  (3, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 3)  (3, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    2      (2, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 3)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (1, 3)  (3, 3)      SOURCE:(3, 3)  (1, 1)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    1      (1, 3)  (3, 3)      SOURCE:(1, 3)  (1, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (3, 3)    2      (1, 3)  (3, 3)      SOURCE:(1, 1)  (1, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (1, 3)  (3, 3)      SOURCE:(3, 1)  (1, 1)        (3, 3)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (0, 3)  (3, 4)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (0, 3)  (3, 4)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 4)    2      (0, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    3      (0, 3)  (3, 4)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (4, 4)  (4, 0)      SOURCE:(0, 4)  (4, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (4, 4)  (4, 0)      SOURCE:(0, 0)  (4, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 0)    2      (4, 4)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    3      (4, 4)  (4, 0)      SOURCE:(4, 4)  (4, 0)        (4, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (3, 4)  (4, 1)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (3, 4)  (4, 1)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 1)    2      (3, 4)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    3      (3, 4)  (4, 1)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 4)  (4, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 4)  (4, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 2)    2      (2, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 4)  (4, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (1, 4)  (4, 3)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (1, 4)  (4, 3)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 3)    2      (1, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    3      (1, 4)  (4, 3)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (0, 4)  (4, 4)      SOURCE:(4, 4)  (0, 0)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    1      (0, 4)  (4, 4)      SOURCE:(0, 4)  (0, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (4, 4)    2      (0, 4)  (4, 4)      SOURCE:(0, 0)  (0, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (0, 4)  (4, 4)      SOURCE:(4, 0)  (0, 0)        (4, 4)     (0, 4)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[L<-U-8] ___________________
[gw8] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.U: 'U'>, <FaceName.L: 'L'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, U -> L
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (5, 0)  (0, 0)      SOURCE:(0, 0)  (5, 5)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    1      (5, 0)  (0, 0)      SOURCE:(5, 0)  (5, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (0, 0)    2      (5, 0)  (0, 0)      SOURCE:(5, 5)  (5, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (5, 0)  (0, 0)      SOURCE:(0, 5)  (5, 5)        (0, 0)     (5, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (4, 0)  (0, 1)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (4, 0)  (0, 1)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 1)    2      (4, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    3      (4, 0)  (0, 1)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (3, 0)  (0, 2)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (3, 0)  (0, 2)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 2)    2      (3, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    3      (3, 0)  (0, 2)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (2, 0)  (0, 3)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (2, 0)  (0, 3)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 3)    2      (2, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    3      (2, 0)  (0, 3)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (1, 0)  (0, 4)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (1, 0)  (0, 4)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 4)    2      (1, 0)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    3      (1, 0)  (0, 4)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (0, 0)  (0, 5)      SOURCE:(5, 0)  (0, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    1      (0, 0)  (0, 5)      SOURCE:(5, 5)  (0, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 5)    2      (0, 0)  (0, 5)      SOURCE:(0, 5)  (0, 5)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    3      (0, 0)  (0, 5)      SOURCE:(0, 0)  (0, 5)        (0, 5)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (5, 1)  (1, 0)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (5, 1)  (1, 0)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (1, 0)    2      (5, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    3      (5, 1)  (1, 0)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (4, 1)  (1, 1)      SOURCE:(1, 1)  (4, 4)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    1      (4, 1)  (1, 1)      SOURCE:(4, 1)  (4, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (1, 1)    2      (4, 1)  (1, 1)      SOURCE:(4, 4)  (4, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (4, 1)  (1, 1)      SOURCE:(1, 4)  (4, 4)        (1, 1)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (3, 1)  (1, 2)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (3, 1)  (1, 2)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 2)    2      (3, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    3      (3, 1)  (1, 2)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (2, 1)  (1, 3)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (2, 1)  (1, 3)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 3)    2      (2, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    3      (2, 1)  (1, 3)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (1, 1)  (1, 4)      SOURCE:(4, 1)  (1, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (1, 1)  (1, 4)      SOURCE:(4, 4)  (1, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 4)    2      (1, 1)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    3      (1, 1)  (1, 4)      SOURCE:(1, 1)  (1, 4)        (1, 4)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (0, 1)  (1, 5)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    1      (0, 1)  (1, 5)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 5)    2      (0, 1)  (1, 5)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    3      (0, 1)  (1, 5)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (5, 2)  (2, 0)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (5, 2)  (2, 0)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (2, 0)    2      (5, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    3      (5, 2)  (2, 0)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (4, 2)  (2, 1)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (4, 2)  (2, 1)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 1)    2      (4, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    3      (4, 2)  (2, 1)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (3, 2)  (2, 2)      SOURCE:(2, 2)  (3, 3)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    1      (3, 2)  (2, 2)      SOURCE:(3, 2)  (3, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (2, 2)    2      (3, 2)  (2, 2)      SOURCE:(3, 3)  (3, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (3, 2)  (2, 2)      SOURCE:(2, 3)  (3, 3)        (2, 2)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (2, 2)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (2, 2)  (2, 3)      SOURCE:(3, 3)  (2, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 3)    2      (2, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    3      (2, 2)  (2, 3)      SOURCE:(2, 2)  (2, 3)        (2, 3)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (1, 2)  (2, 4)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (1, 2)  (2, 4)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 4)    2      (1, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    3      (1, 2)  (2, 4)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (0, 2)  (2, 5)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    1      (0, 2)  (2, 5)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 5)    2      (0, 2)  (2, 5)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    3      (0, 2)  (2, 5)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (5, 3)  (3, 0)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (5, 3)  (3, 0)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (3, 0)    2      (5, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    3      (5, 3)  (3, 0)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (4, 3)  (3, 1)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (4, 3)  (3, 1)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 1)    2      (4, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    3      (4, 3)  (3, 1)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (3, 3)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (3, 3)  (3, 2)      SOURCE:(2, 2)  (3, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 2)    2      (3, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    3      (3, 3)  (3, 2)      SOURCE:(3, 3)  (3, 2)        (3, 2)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (2, 3)  (3, 3)      SOURCE:(3, 3)  (2, 2)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    1      (2, 3)  (3, 3)      SOURCE:(2, 3)  (2, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (3, 3)    2      (2, 3)  (3, 3)      SOURCE:(2, 2)  (2, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (2, 3)  (3, 3)      SOURCE:(3, 2)  (2, 2)        (3, 3)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (1, 3)  (3, 4)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (1, 3)  (3, 4)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 4)    2      (1, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    3      (1, 3)  (3, 4)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (0, 3)  (3, 5)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    1      (0, 3)  (3, 5)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 5)    2      (0, 3)  (3, 5)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    3      (0, 3)  (3, 5)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (5, 4)  (4, 0)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (5, 4)  (4, 0)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (4, 0)    2      (5, 4)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    3      (5, 4)  (4, 0)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (4, 4)  (4, 1)      SOURCE:(1, 4)  (4, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (4, 4)  (4, 1)      SOURCE:(1, 1)  (4, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 1)    2      (4, 4)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    3      (4, 4)  (4, 1)      SOURCE:(4, 4)  (4, 1)        (4, 1)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (3, 4)  (4, 2)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (3, 4)  (4, 2)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 2)    2      (3, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    3      (3, 4)  (4, 2)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (2, 4)  (4, 3)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (2, 4)  (4, 3)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 3)    2      (2, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    3      (2, 4)  (4, 3)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (1, 4)  (4, 4)      SOURCE:(4, 4)  (1, 1)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    1      (1, 4)  (4, 4)      SOURCE:(1, 4)  (1, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (4, 4)    2      (1, 4)  (4, 4)      SOURCE:(1, 1)  (1, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (1, 4)  (4, 4)      SOURCE:(4, 1)  (1, 1)        (4, 4)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (0, 4)  (4, 5)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    1      (0, 4)  (4, 5)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 5)    2      (0, 4)  (4, 5)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    3      (0, 4)  (4, 5)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (5, 5)  (5, 0)      SOURCE:(0, 5)  (5, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    1      (5, 5)  (5, 0)      SOURCE:(0, 0)  (5, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (5, 0)    2      (5, 5)  (5, 0)      SOURCE:(5, 0)  (5, 0)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    3      (5, 5)  (5, 0)      SOURCE:(5, 5)  (5, 0)        (5, 0)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (4, 5)  (5, 1)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    1      (4, 5)  (5, 1)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (5, 1)    2      (4, 5)  (5, 1)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    3      (4, 5)  (5, 1)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (3, 5)  (5, 2)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    1      (3, 5)  (5, 2)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (5, 2)    2      (3, 5)  (5, 2)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    3      (3, 5)  (5, 2)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (2, 5)  (5, 3)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    1      (2, 5)  (5, 3)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (5, 3)    2      (2, 5)  (5, 3)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    3      (2, 5)  (5, 3)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (1, 5)  (5, 4)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    1      (1, 5)  (5, 4)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (5, 4)    2      (1, 5)  (5, 4)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    3      (1, 5)  (5, 4)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (0, 5)  (5, 5)      SOURCE:(5, 5)  (0, 0)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    1      (0, 5)  (5, 5)      SOURCE:(0, 5)  (0, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (5, 5)    2      (0, 5)  (5, 5)      SOURCE:(0, 0)  (0, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    3      (0, 5)  (5, 5)      SOURCE:(5, 0)  (0, 0)        (5, 5)     (0, 5)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-L-7] ___________________
[gw9] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.L: 'L'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, L -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 4)  (0, 0)      SOURCE:(0, 0)  (4, 4)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    1      (0, 4)  (0, 0)      SOURCE:(4, 0)  (4, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 0)    2      (0, 4)  (0, 0)      SOURCE:(4, 4)  (4, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 4)  (0, 0)      SOURCE:(0, 4)  (4, 4)        (4, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 4)  (0, 1)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    1      (1, 4)  (0, 1)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (0, 1)    2      (1, 4)  (0, 1)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 4)  (0, 1)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 4)  (0, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 4)  (0, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (0, 2)    2      (2, 4)  (0, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 4)  (0, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 4)  (0, 3)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    1      (3, 4)  (0, 3)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (0, 3)    2      (3, 4)  (0, 3)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 4)  (0, 3)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 4)  (0, 4)      SOURCE:(4, 0)  (0, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (4, 4)  (0, 4)      SOURCE:(4, 4)  (0, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (0, 4)    2      (4, 4)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    3      (4, 4)  (0, 4)      SOURCE:(0, 0)  (0, 4)        (4, 0)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 3)  (1, 0)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    1      (0, 3)  (1, 0)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (1, 0)    2      (0, 3)  (1, 0)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 3)  (1, 0)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 3)  (1, 1)      SOURCE:(1, 1)  (3, 3)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    1      (1, 3)  (1, 1)      SOURCE:(3, 1)  (3, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 1)    2      (1, 3)  (1, 1)      SOURCE:(3, 3)  (3, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 3)  (1, 1)      SOURCE:(1, 3)  (3, 3)        (3, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 3)  (1, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 3)  (1, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 2)    2      (2, 3)  (1, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 3)  (1, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 3)  (1, 3)      SOURCE:(3, 1)  (1, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (3, 3)  (1, 3)      SOURCE:(3, 3)  (1, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (1, 3)    2      (3, 3)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    3      (3, 3)  (1, 3)      SOURCE:(1, 1)  (1, 3)        (3, 1)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 3)  (1, 4)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    1      (4, 3)  (1, 4)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 4)    2      (4, 3)  (1, 4)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (4, 3)  (1, 4)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 2)  (2, 0)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    1      (0, 2)  (2, 0)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    2      (0, 2)  (2, 0)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 2)  (2, 0)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 2)  (2, 3)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    1      (3, 2)  (2, 3)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    2      (3, 2)  (2, 3)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 2)  (2, 3)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 2)  (2, 4)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    1      (4, 2)  (2, 4)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 4)    2      (4, 2)  (2, 4)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 2)  (2, 4)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 1)  (3, 0)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    1      (0, 1)  (3, 0)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 0)    2      (0, 1)  (3, 0)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 1)  (3, 0)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 1)  (3, 1)      SOURCE:(1, 3)  (3, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (1, 1)  (3, 1)      SOURCE:(1, 1)  (3, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (3, 1)    2      (1, 1)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    3      (1, 1)  (3, 1)      SOURCE:(3, 3)  (3, 1)        (1, 3)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 1)  (3, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 1)  (3, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 2)    2      (2, 1)  (3, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 1)  (3, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 1)  (3, 3)      SOURCE:(3, 3)  (1, 1)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    1      (3, 1)  (3, 3)      SOURCE:(1, 3)  (1, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 3)    2      (3, 1)  (3, 3)      SOURCE:(1, 1)  (1, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (3, 1)  (3, 3)      SOURCE:(3, 1)  (1, 1)        (1, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 1)  (3, 4)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    1      (4, 1)  (3, 4)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (3, 4)    2      (4, 1)  (3, 4)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 1)  (3, 4)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 0)  (4, 0)      SOURCE:(0, 4)  (4, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (0, 0)  (4, 0)      SOURCE:(0, 0)  (4, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (4, 0)    2      (0, 0)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    3      (0, 0)  (4, 0)      SOURCE:(4, 4)  (4, 0)        (0, 4)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 0)  (4, 1)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    1      (1, 0)  (4, 1)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 1)    2      (1, 0)  (4, 1)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (1, 0)  (4, 1)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 0)  (4, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 0)  (4, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (4, 2)    2      (2, 0)  (4, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 0)  (4, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 0)  (4, 3)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    1      (3, 0)  (4, 3)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (4, 3)    2      (3, 0)  (4, 3)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 0)  (4, 3)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 0)  (4, 4)      SOURCE:(4, 4)  (0, 0)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    1      (4, 0)  (4, 4)      SOURCE:(0, 4)  (0, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 4)    2      (4, 0)  (4, 4)      SOURCE:(0, 0)  (0, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (4, 0)  (4, 4)      SOURCE:(4, 0)  (0, 0)        (0, 0)     (0, 4)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-L-4] ___________________
[gw2] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.L: 'L'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, L -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (1, 0)  (0, 0)      SOURCE:(1, 1)  (0, 0)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (1, 0)  (0, 0)      SOURCE:(0, 1)  (0, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 0)    2      (1, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    3      (1, 0)  (0, 0)      SOURCE:(1, 0)  (0, 0)        (0, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (0, 0)  (0, 1)      SOURCE:(0, 1)  (1, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    1      (0, 0)  (0, 1)      SOURCE:(0, 0)  (1, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (0, 1)    2      (0, 0)  (0, 1)      SOURCE:(1, 0)  (1, 0)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (0, 0)  (0, 1)      SOURCE:(1, 1)  (1, 0)        (0, 1)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (1, 1)  (1, 0)      SOURCE:(1, 0)  (0, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    1      (1, 1)  (1, 0)      SOURCE:(1, 1)  (0, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (1, 0)    2      (1, 1)  (1, 0)      SOURCE:(0, 1)  (0, 1)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (1, 1)  (1, 0)      SOURCE:(0, 0)  (0, 1)        (1, 0)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (0, 1)  (1, 1)      SOURCE:(0, 0)  (1, 1)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (0, 1)  (1, 1)      SOURCE:(1, 0)  (1, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 1)    2      (0, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    3      (0, 1)  (1, 1)      SOURCE:(0, 1)  (1, 1)        (1, 1)     (1, 0)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-L-5] ___________________
[gw2] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.L: 'L'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, L -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (2, 0)  (0, 0)      SOURCE:(2, 2)  (0, 0)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (2, 0)  (0, 0)      SOURCE:(0, 2)  (0, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 0)    2      (2, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    3      (2, 0)  (0, 0)      SOURCE:(2, 0)  (0, 0)        (0, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 0)  (0, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 0)  (0, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    2      (1, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 0)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (0, 0)  (0, 2)      SOURCE:(0, 2)  (2, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    1      (0, 0)  (0, 2)      SOURCE:(0, 0)  (2, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (0, 2)    2      (0, 0)  (0, 2)      SOURCE:(2, 0)  (2, 0)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (0, 0)  (0, 2)      SOURCE:(2, 2)  (2, 0)        (0, 2)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (2, 1)  (1, 0)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (2, 1)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 0)    2      (2, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    3      (2, 1)  (1, 0)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (0, 1)  (1, 2)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (0, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 2)    2      (0, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    3      (0, 1)  (1, 2)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (2, 2)  (2, 0)      SOURCE:(2, 0)  (0, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    1      (2, 2)  (2, 0)      SOURCE:(2, 2)  (0, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (2, 0)    2      (2, 2)  (2, 0)      SOURCE:(0, 2)  (0, 2)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (2, 2)  (2, 0)      SOURCE:(0, 0)  (0, 2)        (2, 0)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (0, 2)  (2, 2)      SOURCE:(0, 0)  (2, 2)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (0, 2)  (2, 2)      SOURCE:(2, 0)  (2, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 2)    2      (0, 2)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    3      (0, 2)  (2, 2)      SOURCE:(0, 2)  (2, 2)        (2, 2)     (2, 0)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-L-6] ___________________
[gw8] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.L: 'L'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, L -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (3, 0)  (0, 0)      SOURCE:(3, 3)  (0, 0)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (3, 0)  (0, 0)      SOURCE:(0, 3)  (0, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 0)    2      (3, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    3      (3, 0)  (0, 0)      SOURCE:(3, 0)  (0, 0)        (0, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (2, 0)  (0, 1)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (2, 0)  (0, 1)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 1)    2      (2, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    3      (2, 0)  (0, 1)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (1, 0)  (0, 2)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (1, 0)  (0, 2)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 2)    2      (1, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    3      (1, 0)  (0, 2)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (0, 0)  (0, 3)      SOURCE:(0, 3)  (3, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    1      (0, 0)  (0, 3)      SOURCE:(0, 0)  (3, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (0, 3)    2      (0, 0)  (0, 3)      SOURCE:(3, 0)  (3, 0)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (0, 0)  (0, 3)      SOURCE:(3, 3)  (3, 0)        (0, 3)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (3, 1)  (1, 0)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (3, 1)  (1, 0)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 0)    2      (3, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    3      (3, 1)  (1, 0)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (2, 1)  (1, 1)      SOURCE:(2, 2)  (1, 1)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (2, 1)  (1, 1)      SOURCE:(1, 2)  (1, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 1)    2      (2, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    3      (2, 1)  (1, 1)      SOURCE:(2, 1)  (1, 1)        (1, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (1, 1)  (1, 2)      SOURCE:(1, 2)  (2, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    1      (1, 1)  (1, 2)      SOURCE:(1, 1)  (2, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (1, 2)    2      (1, 1)  (1, 2)      SOURCE:(2, 1)  (2, 1)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (1, 1)  (1, 2)      SOURCE:(2, 2)  (2, 1)        (1, 2)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (0, 1)  (1, 3)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (0, 1)  (1, 3)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 3)    2      (0, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    3      (0, 1)  (1, 3)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (3, 2)  (2, 0)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (3, 2)  (2, 0)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 0)    2      (3, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    3      (3, 2)  (2, 0)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (2, 2)  (2, 1)      SOURCE:(2, 1)  (1, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    1      (2, 2)  (2, 1)      SOURCE:(2, 2)  (1, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (2, 1)    2      (2, 2)  (2, 1)      SOURCE:(1, 2)  (1, 2)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (2, 2)  (2, 1)      SOURCE:(1, 1)  (1, 2)        (2, 1)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (1, 2)  (2, 2)      SOURCE:(1, 1)  (2, 2)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (1, 2)  (2, 2)      SOURCE:(2, 1)  (2, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 2)    2      (1, 2)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    3      (1, 2)  (2, 2)      SOURCE:(1, 2)  (2, 2)        (2, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (0, 2)  (2, 3)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (0, 2)  (2, 3)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 3)    2      (0, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    3      (0, 2)  (2, 3)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (3, 3)  (3, 0)      SOURCE:(3, 0)  (0, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    1      (3, 3)  (3, 0)      SOURCE:(3, 3)  (0, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (3, 0)    2      (3, 3)  (3, 0)      SOURCE:(0, 3)  (0, 3)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (3, 3)  (3, 0)      SOURCE:(0, 0)  (0, 3)        (3, 0)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (2, 3)  (3, 1)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (2, 3)  (3, 1)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 1)    2      (2, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    3      (2, 3)  (3, 1)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (1, 3)  (3, 2)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (1, 3)  (3, 2)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 2)    2      (1, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    3      (1, 3)  (3, 2)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (0, 3)  (3, 3)      SOURCE:(0, 0)  (3, 3)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (0, 3)  (3, 3)      SOURCE:(3, 0)  (3, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 3)    2      (0, 3)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    3      (0, 3)  (3, 3)      SOURCE:(0, 3)  (3, 3)        (3, 3)     (3, 0)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[U<-R-8] ___________________
[gw4] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.R: 'R'>, <FaceName.U: 'U'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, R -> U
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (5, 0)  (0, 0)      SOURCE:(5, 5)  (0, 0)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (5, 0)  (0, 0)      SOURCE:(0, 5)  (0, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (0, 0)    2      (5, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    3      (5, 0)  (0, 0)      SOURCE:(5, 0)  (0, 0)        (0, 0)     (0, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (4, 0)  (0, 1)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (4, 0)  (0, 1)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 1)    2      (4, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    3      (4, 0)  (0, 1)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (3, 0)  (0, 2)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (3, 0)  (0, 2)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 2)    2      (3, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    3      (3, 0)  (0, 2)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (2, 0)  (0, 3)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (2, 0)  (0, 3)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 3)    2      (2, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    3      (2, 0)  (0, 3)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (1, 0)  (0, 4)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (1, 0)  (0, 4)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 4)    2      (1, 0)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    3      (1, 0)  (0, 4)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (0, 0)  (0, 5)      SOURCE:(0, 5)  (5, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    1      (0, 0)  (0, 5)      SOURCE:(0, 0)  (5, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (0, 5)    2      (0, 0)  (0, 5)      SOURCE:(5, 0)  (5, 0)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    3      (0, 0)  (0, 5)      SOURCE:(5, 5)  (5, 0)        (0, 5)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (5, 1)  (1, 0)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (5, 1)  (1, 0)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (1, 0)    2      (5, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    3      (5, 1)  (1, 0)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (4, 1)  (1, 1)      SOURCE:(4, 4)  (1, 1)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (4, 1)  (1, 1)      SOURCE:(1, 4)  (1, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 1)    2      (4, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    3      (4, 1)  (1, 1)      SOURCE:(4, 1)  (1, 1)        (1, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (3, 1)  (1, 2)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (3, 1)  (1, 2)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 2)    2      (3, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    3      (3, 1)  (1, 2)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (2, 1)  (1, 3)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (2, 1)  (1, 3)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 3)    2      (2, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    3      (2, 1)  (1, 3)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (1, 1)  (1, 4)      SOURCE:(1, 4)  (4, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    1      (1, 1)  (1, 4)      SOURCE:(1, 1)  (4, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (1, 4)    2      (1, 1)  (1, 4)      SOURCE:(4, 1)  (4, 1)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (1, 1)  (1, 4)      SOURCE:(4, 4)  (4, 1)        (1, 4)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (0, 1)  (1, 5)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    1      (0, 1)  (1, 5)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 5)    2      (0, 1)  (1, 5)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    3      (0, 1)  (1, 5)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (5, 2)  (2, 0)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (5, 2)  (2, 0)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (2, 0)    2      (5, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    3      (5, 2)  (2, 0)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (4, 2)  (2, 1)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (4, 2)  (2, 1)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 1)    2      (4, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    3      (4, 2)  (2, 1)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (3, 2)  (2, 2)      SOURCE:(3, 3)  (2, 2)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (3, 2)  (2, 2)      SOURCE:(2, 3)  (2, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 2)    2      (3, 2)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    3      (3, 2)  (2, 2)      SOURCE:(3, 2)  (2, 2)        (2, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (2, 2)  (2, 3)      SOURCE:(2, 3)  (3, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    1      (2, 2)  (2, 3)      SOURCE:(2, 2)  (3, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (2, 3)    2      (2, 2)  (2, 3)      SOURCE:(3, 2)  (3, 2)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (2, 2)  (2, 3)      SOURCE:(3, 3)  (3, 2)        (2, 3)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (1, 2)  (2, 4)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (1, 2)  (2, 4)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 4)    2      (1, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    3      (1, 2)  (2, 4)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (0, 2)  (2, 5)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    1      (0, 2)  (2, 5)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 5)    2      (0, 2)  (2, 5)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    3      (0, 2)  (2, 5)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (5, 3)  (3, 0)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (5, 3)  (3, 0)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (3, 0)    2      (5, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    3      (5, 3)  (3, 0)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (4, 3)  (3, 1)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (4, 3)  (3, 1)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 1)    2      (4, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    3      (4, 3)  (3, 1)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (3, 3)  (3, 2)      SOURCE:(3, 2)  (2, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    1      (3, 3)  (3, 2)      SOURCE:(3, 3)  (2, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (3, 2)    2      (3, 3)  (3, 2)      SOURCE:(2, 3)  (2, 3)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (3, 3)  (3, 2)      SOURCE:(2, 2)  (2, 3)        (3, 2)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (2, 3)  (3, 3)      SOURCE:(2, 2)  (3, 3)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (2, 3)  (3, 3)      SOURCE:(3, 2)  (3, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 3)    2      (2, 3)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    3      (2, 3)  (3, 3)      SOURCE:(2, 3)  (3, 3)        (3, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (1, 3)  (3, 4)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (1, 3)  (3, 4)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 4)    2      (1, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    3      (1, 3)  (3, 4)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (0, 3)  (3, 5)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    1      (0, 3)  (3, 5)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 5)    2      (0, 3)  (3, 5)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    3      (0, 3)  (3, 5)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (5, 4)  (4, 0)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (5, 4)  (4, 0)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (4, 0)    2      (5, 4)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    3      (5, 4)  (4, 0)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (4, 4)  (4, 1)      SOURCE:(4, 1)  (1, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    1      (4, 4)  (4, 1)      SOURCE:(4, 4)  (1, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (4, 1)    2      (4, 4)  (4, 1)      SOURCE:(1, 4)  (1, 4)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (4, 4)  (4, 1)      SOURCE:(1, 1)  (1, 4)        (4, 1)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (3, 4)  (4, 2)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (3, 4)  (4, 2)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 2)    2      (3, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    3      (3, 4)  (4, 2)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (2, 4)  (4, 3)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (2, 4)  (4, 3)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 3)    2      (2, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    3      (2, 4)  (4, 3)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (1, 4)  (4, 4)      SOURCE:(1, 1)  (4, 4)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (1, 4)  (4, 4)      SOURCE:(4, 1)  (4, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 4)    2      (1, 4)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    3      (1, 4)  (4, 4)      SOURCE:(1, 4)  (4, 4)        (4, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (0, 4)  (4, 5)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    1      (0, 4)  (4, 5)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 5)    2      (0, 4)  (4, 5)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    3      (0, 4)  (4, 5)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (5, 5)  (5, 0)      SOURCE:(5, 0)  (0, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    1      (5, 5)  (5, 0)      SOURCE:(5, 5)  (0, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (5, 0)    2      (5, 5)  (5, 0)      SOURCE:(0, 5)  (0, 5)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    3      (5, 5)  (5, 0)      SOURCE:(0, 0)  (0, 5)        (5, 0)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (4, 5)  (5, 1)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    1      (4, 5)  (5, 1)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (5, 1)    2      (4, 5)  (5, 1)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    3      (4, 5)  (5, 1)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (3, 5)  (5, 2)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    1      (3, 5)  (5, 2)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (5, 2)    2      (3, 5)  (5, 2)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    3      (3, 5)  (5, 2)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (2, 5)  (5, 3)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    1      (2, 5)  (5, 3)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (5, 3)    2      (2, 5)  (5, 3)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    3      (2, 5)  (5, 3)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (1, 5)  (5, 4)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    1      (1, 5)  (5, 4)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (5, 4)    2      (1, 5)  (5, 4)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    3      (1, 5)  (5, 4)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (0, 5)  (5, 5)      SOURCE:(0, 0)  (5, 5)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    1      (0, 5)  (5, 5)      SOURCE:(5, 0)  (5, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (5, 5)    2      (0, 5)  (5, 5)      SOURCE:(5, 5)  (5, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    3      (0, 5)  (5, 5)      SOURCE:(0, 5)  (5, 5)        (5, 5)     (5, 0)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-R-4] ___________________
[gw12] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 4, face_pair = (<FaceName.R: 'R'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=4, R -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 1)  (0, 0)      SOURCE:(0, 0)  (1, 1)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (0, 0)    1      (0, 1)  (0, 0)      SOURCE:(1, 0)  (1, 1)        (0, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 0)    2      (0, 1)  (0, 0)      SOURCE:(1, 1)  (1, 1)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 1)  (0, 0)      SOURCE:(0, 1)  (1, 1)        (1, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 1)  (0, 1)      SOURCE:(1, 0)  (0, 1)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 1)  (0, 1)      SOURCE:(1, 1)  (0, 1)        (0, 1)     (0, 0)
E             marker_t_not_at_s2  (0, 1)    2      (1, 1)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (0, 1)    3      (1, 1)  (0, 1)      SOURCE:(0, 0)  (0, 1)        (1, 0)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 0)  (1, 0)      SOURCE:(0, 1)  (1, 0)        (0, 0)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (0, 0)  (1, 0)      SOURCE:(0, 0)  (1, 0)        (1, 0)     (1, 1)
E             marker_t_not_at_s2  (1, 0)    2      (0, 0)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (1, 1)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    3      (0, 0)  (1, 0)      SOURCE:(1, 1)  (1, 0)        (0, 1)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 0)  (1, 1)      SOURCE:(1, 1)  (0, 0)        (1, 0)     (0, 0)
E             marker_t_not_at_s2  (1, 1)    1      (1, 0)  (1, 1)      SOURCE:(0, 1)  (0, 0)        (1, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 1)    2      (1, 0)  (1, 1)      SOURCE:(0, 0)  (0, 0)        (0, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 0)  (1, 1)      SOURCE:(1, 0)  (0, 0)        (0, 0)     (0, 1)
E             
E             Total failures: 16
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-L-7] ___________________
[gw10] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.L: 'L'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, L -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (4, 0)  (0, 0)      SOURCE:(4, 4)  (0, 0)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (4, 0)  (0, 0)      SOURCE:(0, 4)  (0, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 0)    2      (4, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    3      (4, 0)  (0, 0)      SOURCE:(4, 0)  (0, 0)        (0, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (3, 0)  (0, 1)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (3, 0)  (0, 1)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 1)    2      (3, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    3      (3, 0)  (0, 1)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 0)  (0, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 0)  (0, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    2      (2, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 0)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (1, 0)  (0, 3)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (1, 0)  (0, 3)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 3)    2      (1, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    3      (1, 0)  (0, 3)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (0, 0)  (0, 4)      SOURCE:(0, 4)  (4, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    1      (0, 0)  (0, 4)      SOURCE:(0, 0)  (4, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (0, 4)    2      (0, 0)  (0, 4)      SOURCE:(4, 0)  (4, 0)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (0, 0)  (0, 4)      SOURCE:(4, 4)  (4, 0)        (0, 4)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (4, 1)  (1, 0)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (4, 1)  (1, 0)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 0)    2      (4, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    3      (4, 1)  (1, 0)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (3, 1)  (1, 1)      SOURCE:(3, 3)  (1, 1)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (3, 1)  (1, 1)      SOURCE:(1, 3)  (1, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 1)    2      (3, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    3      (3, 1)  (1, 1)      SOURCE:(3, 1)  (1, 1)        (1, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (1, 1)  (1, 3)      SOURCE:(1, 3)  (3, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    1      (1, 1)  (1, 3)      SOURCE:(1, 1)  (3, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (1, 3)    2      (1, 1)  (1, 3)      SOURCE:(3, 1)  (3, 1)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (1, 1)  (1, 3)      SOURCE:(3, 3)  (3, 1)        (1, 3)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (0, 1)  (1, 4)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (0, 1)  (1, 4)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 4)    2      (0, 1)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    3      (0, 1)  (1, 4)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (4, 2)  (2, 0)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (4, 2)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 0)    2      (4, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    3      (4, 2)  (2, 0)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (3, 2)  (2, 1)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (3, 2)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 1)    2      (3, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    3      (3, 2)  (2, 1)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (1, 2)  (2, 3)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (1, 2)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 3)    2      (1, 2)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    3      (1, 2)  (2, 3)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (0, 2)  (2, 4)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (0, 2)  (2, 4)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 4)    2      (0, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    3      (0, 2)  (2, 4)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (4, 3)  (3, 0)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (4, 3)  (3, 0)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 0)    2      (4, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    3      (4, 3)  (3, 0)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (3, 3)  (3, 1)      SOURCE:(3, 1)  (1, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    1      (3, 3)  (3, 1)      SOURCE:(3, 3)  (1, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (3, 1)    2      (3, 3)  (3, 1)      SOURCE:(1, 3)  (1, 3)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (3, 3)  (3, 1)      SOURCE:(1, 1)  (1, 3)        (3, 1)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 3)  (3, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 3)  (3, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    2      (2, 3)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 3)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (1, 3)  (3, 3)      SOURCE:(1, 1)  (3, 3)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (1, 3)  (3, 3)      SOURCE:(3, 1)  (3, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 3)    2      (1, 3)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    3      (1, 3)  (3, 3)      SOURCE:(1, 3)  (3, 3)        (3, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (0, 3)  (3, 4)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (0, 3)  (3, 4)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 4)    2      (0, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    3      (0, 3)  (3, 4)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (4, 4)  (4, 0)      SOURCE:(4, 0)  (0, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    1      (4, 4)  (4, 0)      SOURCE:(4, 4)  (0, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (4, 0)    2      (4, 4)  (4, 0)      SOURCE:(0, 4)  (0, 4)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (4, 4)  (4, 0)      SOURCE:(0, 0)  (0, 4)        (4, 0)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (3, 4)  (4, 1)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (3, 4)  (4, 1)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 1)    2      (3, 4)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    3      (3, 4)  (4, 1)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 4)  (4, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 4)  (4, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 2)    2      (2, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 4)  (4, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (1, 4)  (4, 3)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (1, 4)  (4, 3)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 3)    2      (1, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    3      (1, 4)  (4, 3)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (0, 4)  (4, 4)      SOURCE:(0, 0)  (4, 4)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (0, 4)  (4, 4)      SOURCE:(4, 0)  (4, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 4)    2      (0, 4)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    3      (0, 4)  (4, 4)      SOURCE:(0, 4)  (4, 4)        (4, 4)     (4, 0)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-R-6] ___________________
[gw10] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 6, face_pair = (<FaceName.R: 'R'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=6, R -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 3)  (0, 0)      SOURCE:(0, 0)  (3, 3)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (0, 0)    1      (0, 3)  (0, 0)      SOURCE:(3, 0)  (3, 3)        (0, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 0)    2      (0, 3)  (0, 0)      SOURCE:(3, 3)  (3, 3)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 3)  (0, 0)      SOURCE:(0, 3)  (3, 3)        (3, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 3)  (0, 1)      SOURCE:(0, 1)  (3, 2)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (0, 1)    1      (1, 3)  (0, 1)      SOURCE:(2, 0)  (3, 2)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (0, 1)    2      (1, 3)  (0, 1)      SOURCE:(3, 2)  (3, 2)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 3)  (0, 1)      SOURCE:(1, 3)  (3, 2)        (3, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 3)  (0, 2)      SOURCE:(0, 2)  (3, 1)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (0, 2)    1      (2, 3)  (0, 2)      SOURCE:(1, 0)  (3, 1)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (0, 2)    2      (2, 3)  (0, 2)      SOURCE:(3, 1)  (3, 1)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 3)  (0, 2)      SOURCE:(2, 3)  (3, 1)        (3, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 3)  (0, 3)      SOURCE:(3, 0)  (0, 3)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (3, 3)  (0, 3)      SOURCE:(3, 3)  (0, 3)        (0, 3)     (0, 0)
E             marker_t_not_at_s2  (0, 3)    2      (3, 3)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (0, 3)    3      (3, 3)  (0, 3)      SOURCE:(0, 0)  (0, 3)        (3, 0)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 2)  (1, 0)      SOURCE:(1, 0)  (2, 3)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 0)    1      (0, 2)  (1, 0)      SOURCE:(3, 1)  (2, 3)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (1, 0)    2      (0, 2)  (1, 0)      SOURCE:(2, 3)  (2, 3)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 2)  (1, 0)      SOURCE:(0, 2)  (2, 3)        (2, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 2)  (1, 1)      SOURCE:(1, 1)  (2, 2)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (1, 1)    1      (1, 2)  (1, 1)      SOURCE:(2, 1)  (2, 2)        (1, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 1)    2      (1, 2)  (1, 1)      SOURCE:(2, 2)  (2, 2)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 2)  (1, 1)      SOURCE:(1, 2)  (2, 2)        (2, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 2)  (1, 2)      SOURCE:(2, 1)  (1, 2)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 2)  (1, 2)      SOURCE:(2, 2)  (1, 2)        (1, 2)     (1, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 2)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    3      (2, 2)  (1, 2)      SOURCE:(1, 1)  (1, 2)        (2, 1)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 2)  (1, 3)      SOURCE:(1, 3)  (2, 0)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (1, 3)    1      (3, 2)  (1, 3)      SOURCE:(0, 1)  (2, 0)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 3)    2      (3, 2)  (1, 3)      SOURCE:(2, 0)  (2, 0)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 2)  (1, 3)      SOURCE:(3, 2)  (2, 0)        (2, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 1)  (2, 0)      SOURCE:(2, 0)  (1, 3)        (0, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 0)    1      (0, 1)  (2, 0)      SOURCE:(3, 2)  (1, 3)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 0)    2      (0, 1)  (2, 0)      SOURCE:(1, 3)  (1, 3)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 1)  (2, 0)      SOURCE:(0, 1)  (1, 3)        (1, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 1)  (2, 1)      SOURCE:(1, 2)  (2, 1)        (1, 1)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 1)  (2, 1)      SOURCE:(1, 1)  (2, 1)        (2, 1)     (2, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 1)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (2, 2)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    3      (1, 1)  (2, 1)      SOURCE:(2, 2)  (2, 1)        (1, 2)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 1)  (2, 2)      SOURCE:(2, 2)  (1, 1)        (2, 1)     (1, 1)
E             marker_t_not_at_s2  (2, 2)    1      (2, 1)  (2, 2)      SOURCE:(1, 2)  (1, 1)        (2, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 2)    2      (2, 1)  (2, 2)      SOURCE:(1, 1)  (1, 1)        (1, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (2, 1)  (2, 2)      SOURCE:(2, 1)  (1, 1)        (1, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 1)  (2, 3)      SOURCE:(2, 3)  (1, 0)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 3)    1      (3, 1)  (2, 3)      SOURCE:(0, 2)  (1, 0)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 3)    2      (3, 1)  (2, 3)      SOURCE:(1, 0)  (1, 0)        (0, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 1)  (2, 3)      SOURCE:(3, 1)  (1, 0)        (1, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 0)  (3, 0)      SOURCE:(0, 3)  (3, 0)        (0, 0)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (0, 0)  (3, 0)      SOURCE:(0, 0)  (3, 0)        (3, 0)     (3, 3)
E             marker_t_not_at_s2  (3, 0)    2      (0, 0)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (3, 3)     (0, 3)
E             marker_t_not_at_s2  (3, 0)    3      (0, 0)  (3, 0)      SOURCE:(3, 3)  (3, 0)        (0, 3)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 0)  (3, 1)      SOURCE:(3, 1)  (0, 2)        (1, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 1)    1      (1, 0)  (3, 1)      SOURCE:(2, 3)  (0, 2)        (3, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 1)    2      (1, 0)  (3, 1)      SOURCE:(0, 2)  (0, 2)        (2, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 0)  (3, 1)      SOURCE:(1, 0)  (0, 2)        (0, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 0)  (3, 2)      SOURCE:(3, 2)  (0, 1)        (2, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 2)    1      (2, 0)  (3, 2)      SOURCE:(1, 3)  (0, 1)        (3, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 2)    2      (2, 0)  (3, 2)      SOURCE:(0, 1)  (0, 1)        (1, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 0)  (3, 2)      SOURCE:(2, 0)  (0, 1)        (0, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 0)  (3, 3)      SOURCE:(3, 3)  (0, 0)        (3, 0)     (0, 0)
E             marker_t_not_at_s2  (3, 3)    1      (3, 0)  (3, 3)      SOURCE:(0, 3)  (0, 0)        (3, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 3)    2      (3, 0)  (3, 3)      SOURCE:(0, 0)  (0, 0)        (0, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (3, 0)  (3, 3)      SOURCE:(3, 0)  (0, 0)        (0, 0)     (0, 3)
E             
E             Total failures: 64
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-R-7] ___________________
[gw3] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 7, face_pair = (<FaceName.R: 'R'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=7, R -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 4)  (0, 0)      SOURCE:(0, 0)  (4, 4)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (0, 0)    1      (0, 4)  (0, 0)      SOURCE:(4, 0)  (4, 4)        (0, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 0)    2      (0, 4)  (0, 0)      SOURCE:(4, 4)  (4, 4)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 4)  (0, 0)      SOURCE:(0, 4)  (4, 4)        (4, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 4)  (0, 1)      SOURCE:(0, 1)  (4, 3)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (0, 1)    1      (1, 4)  (0, 1)      SOURCE:(3, 0)  (4, 3)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (0, 1)    2      (1, 4)  (0, 1)      SOURCE:(4, 3)  (4, 3)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 4)  (0, 1)      SOURCE:(1, 4)  (4, 3)        (4, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 4)  (0, 2)      SOURCE:(0, 2)  (4, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 4)  (0, 2)      SOURCE:(2, 0)  (4, 2)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (0, 2)    2      (2, 4)  (0, 2)      SOURCE:(4, 2)  (4, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 4)  (0, 2)      SOURCE:(2, 4)  (4, 2)        (4, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 4)  (0, 3)      SOURCE:(0, 3)  (4, 1)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (0, 3)    1      (3, 4)  (0, 3)      SOURCE:(1, 0)  (4, 1)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (0, 3)    2      (3, 4)  (0, 3)      SOURCE:(4, 1)  (4, 1)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 4)  (0, 3)      SOURCE:(3, 4)  (4, 1)        (4, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 4)  (0, 4)      SOURCE:(4, 0)  (0, 4)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (4, 4)  (0, 4)      SOURCE:(4, 4)  (0, 4)        (0, 4)     (0, 0)
E             marker_t_not_at_s2  (0, 4)    2      (4, 4)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (0, 4)    3      (4, 4)  (0, 4)      SOURCE:(0, 0)  (0, 4)        (4, 0)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 3)  (1, 0)      SOURCE:(1, 0)  (3, 4)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 0)    1      (0, 3)  (1, 0)      SOURCE:(4, 1)  (3, 4)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (1, 0)    2      (0, 3)  (1, 0)      SOURCE:(3, 4)  (3, 4)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 3)  (1, 0)      SOURCE:(0, 3)  (3, 4)        (3, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 3)  (1, 1)      SOURCE:(1, 1)  (3, 3)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (1, 1)    1      (1, 3)  (1, 1)      SOURCE:(3, 1)  (3, 3)        (1, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 1)    2      (1, 3)  (1, 1)      SOURCE:(3, 3)  (3, 3)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 3)  (1, 1)      SOURCE:(1, 3)  (3, 3)        (3, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 3)  (1, 2)      SOURCE:(1, 2)  (3, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (1, 2)    1      (2, 3)  (1, 2)      SOURCE:(2, 1)  (3, 2)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (1, 2)    2      (2, 3)  (1, 2)      SOURCE:(3, 2)  (3, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 3)  (1, 2)      SOURCE:(2, 3)  (3, 2)        (3, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 3)  (1, 3)      SOURCE:(3, 1)  (1, 3)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (3, 3)  (1, 3)      SOURCE:(3, 3)  (1, 3)        (1, 3)     (1, 1)
E             marker_t_not_at_s2  (1, 3)    2      (3, 3)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (1, 3)    3      (3, 3)  (1, 3)      SOURCE:(1, 1)  (1, 3)        (3, 1)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 3)  (1, 4)      SOURCE:(1, 4)  (3, 0)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (1, 4)    1      (4, 3)  (1, 4)      SOURCE:(0, 1)  (3, 0)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 4)    2      (4, 3)  (1, 4)      SOURCE:(3, 0)  (3, 0)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (4, 3)  (1, 4)      SOURCE:(4, 3)  (3, 0)        (3, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 2)  (2, 0)      SOURCE:(2, 0)  (2, 4)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 0)    1      (0, 2)  (2, 0)      SOURCE:(4, 2)  (2, 4)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    2      (0, 2)  (2, 0)      SOURCE:(2, 4)  (2, 4)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 2)  (2, 0)      SOURCE:(0, 2)  (2, 4)        (2, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 2)  (2, 1)      SOURCE:(2, 1)  (2, 3)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 1)    1      (1, 2)  (2, 1)      SOURCE:(3, 2)  (2, 3)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 1)    2      (1, 2)  (2, 1)      SOURCE:(2, 3)  (2, 3)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 2)  (2, 1)      SOURCE:(1, 2)  (2, 3)        (2, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 2)  (2, 3)      SOURCE:(2, 3)  (2, 1)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 3)    1      (3, 2)  (2, 3)      SOURCE:(1, 2)  (2, 1)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    2      (3, 2)  (2, 3)      SOURCE:(2, 1)  (2, 1)        (1, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (3, 2)  (2, 3)      SOURCE:(3, 2)  (2, 1)        (2, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 2)  (2, 4)      SOURCE:(2, 4)  (2, 0)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 4)    1      (4, 2)  (2, 4)      SOURCE:(0, 2)  (2, 0)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 4)    2      (4, 2)  (2, 4)      SOURCE:(2, 0)  (2, 0)        (0, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 2)  (2, 4)      SOURCE:(4, 2)  (2, 0)        (2, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 1)  (3, 0)      SOURCE:(3, 0)  (1, 4)        (0, 1)     (1, 4)
E             marker_t_not_at_s2  (3, 0)    1      (0, 1)  (3, 0)      SOURCE:(4, 3)  (1, 4)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (3, 0)    2      (0, 1)  (3, 0)      SOURCE:(1, 4)  (1, 4)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 1)  (3, 0)      SOURCE:(0, 1)  (1, 4)        (1, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 1)  (3, 1)      SOURCE:(1, 3)  (3, 1)        (1, 1)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (1, 1)  (3, 1)      SOURCE:(1, 1)  (3, 1)        (3, 1)     (3, 3)
E             marker_t_not_at_s2  (3, 1)    2      (1, 1)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (3, 3)     (1, 3)
E             marker_t_not_at_s2  (3, 1)    3      (1, 1)  (3, 1)      SOURCE:(3, 3)  (3, 1)        (1, 3)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 1)  (3, 2)      SOURCE:(3, 2)  (1, 2)        (2, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 1)  (3, 2)      SOURCE:(2, 3)  (1, 2)        (3, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 2)    2      (2, 1)  (3, 2)      SOURCE:(1, 2)  (1, 2)        (2, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (2, 1)  (3, 2)      SOURCE:(2, 1)  (1, 2)        (1, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 1)  (3, 3)      SOURCE:(3, 3)  (1, 1)        (3, 1)     (1, 1)
E             marker_t_not_at_s2  (3, 3)    1      (3, 1)  (3, 3)      SOURCE:(1, 3)  (1, 1)        (3, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 3)    2      (3, 1)  (3, 3)      SOURCE:(1, 1)  (1, 1)        (1, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (3, 1)  (3, 3)      SOURCE:(3, 1)  (1, 1)        (1, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 1)  (3, 4)      SOURCE:(3, 4)  (1, 0)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (3, 4)    1      (4, 1)  (3, 4)      SOURCE:(0, 3)  (1, 0)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (3, 4)    2      (4, 1)  (3, 4)      SOURCE:(1, 0)  (1, 0)        (0, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 1)  (3, 4)      SOURCE:(4, 1)  (1, 0)        (1, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 0)  (4, 0)      SOURCE:(0, 4)  (4, 0)        (0, 0)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (0, 0)  (4, 0)      SOURCE:(0, 0)  (4, 0)        (4, 0)     (4, 4)
E             marker_t_not_at_s2  (4, 0)    2      (0, 0)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (4, 4)     (0, 4)
E             marker_t_not_at_s2  (4, 0)    3      (0, 0)  (4, 0)      SOURCE:(4, 4)  (4, 0)        (0, 4)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 0)  (4, 1)      SOURCE:(4, 1)  (0, 3)        (1, 0)     (0, 3)
E             marker_t_not_at_s2  (4, 1)    1      (1, 0)  (4, 1)      SOURCE:(3, 4)  (0, 3)        (4, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 1)    2      (1, 0)  (4, 1)      SOURCE:(0, 3)  (0, 3)        (3, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (1, 0)  (4, 1)      SOURCE:(1, 0)  (0, 3)        (0, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 0)  (4, 2)      SOURCE:(4, 2)  (0, 2)        (2, 0)     (0, 2)
E             marker_t_not_at_s2  (4, 2)    1      (2, 0)  (4, 2)      SOURCE:(2, 4)  (0, 2)        (4, 2)     (2, 0)
E             marker_t_not_at_s2  (4, 2)    2      (2, 0)  (4, 2)      SOURCE:(0, 2)  (0, 2)        (2, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 0)  (4, 2)      SOURCE:(2, 0)  (0, 2)        (0, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 0)  (4, 3)      SOURCE:(4, 3)  (0, 1)        (3, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 3)    1      (3, 0)  (4, 3)      SOURCE:(1, 4)  (0, 1)        (4, 3)     (3, 0)
E             marker_t_not_at_s2  (4, 3)    2      (3, 0)  (4, 3)      SOURCE:(0, 1)  (0, 1)        (1, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 0)  (4, 3)      SOURCE:(3, 0)  (0, 1)        (0, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 0)  (4, 4)      SOURCE:(4, 4)  (0, 0)        (4, 0)     (0, 0)
E             marker_t_not_at_s2  (4, 4)    1      (4, 0)  (4, 4)      SOURCE:(0, 4)  (0, 0)        (4, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 4)    2      (4, 0)  (4, 4)      SOURCE:(0, 0)  (0, 0)        (0, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (4, 0)  (4, 4)      SOURCE:(4, 0)  (0, 0)        (0, 0)     (0, 4)
E             
E             Total failures: 96
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-R-5] ___________________
[gw11] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 5, face_pair = (<FaceName.R: 'R'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=5, R -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 2)  (0, 0)      SOURCE:(0, 0)  (2, 2)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (0, 0)    1      (0, 2)  (0, 0)      SOURCE:(2, 0)  (2, 2)        (0, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 0)    2      (0, 2)  (0, 0)      SOURCE:(2, 2)  (2, 2)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 2)  (0, 0)      SOURCE:(0, 2)  (2, 2)        (2, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 2)  (0, 1)      SOURCE:(0, 1)  (2, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (0, 1)    1      (1, 2)  (0, 1)      SOURCE:(1, 0)  (2, 1)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (0, 1)    2      (1, 2)  (0, 1)      SOURCE:(2, 1)  (2, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 2)  (0, 1)      SOURCE:(1, 2)  (2, 1)        (2, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 2)  (0, 2)      SOURCE:(2, 0)  (0, 2)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (2, 2)  (0, 2)      SOURCE:(2, 2)  (0, 2)        (0, 2)     (0, 0)
E             marker_t_not_at_s2  (0, 2)    2      (2, 2)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (0, 2)    3      (2, 2)  (0, 2)      SOURCE:(0, 0)  (0, 2)        (2, 0)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 1)  (1, 0)      SOURCE:(1, 0)  (1, 2)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 0)    1      (0, 1)  (1, 0)      SOURCE:(2, 1)  (1, 2)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 0)    2      (0, 1)  (1, 0)      SOURCE:(1, 2)  (1, 2)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 1)  (1, 0)      SOURCE:(0, 1)  (1, 2)        (1, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 1)  (1, 2)      SOURCE:(1, 2)  (1, 0)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 2)    1      (2, 1)  (1, 2)      SOURCE:(0, 1)  (1, 0)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 2)    2      (2, 1)  (1, 2)      SOURCE:(1, 0)  (1, 0)        (0, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 1)  (1, 2)      SOURCE:(2, 1)  (1, 0)        (1, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 0)  (2, 0)      SOURCE:(0, 2)  (2, 0)        (0, 0)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (0, 0)  (2, 0)      SOURCE:(0, 0)  (2, 0)        (2, 0)     (2, 2)
E             marker_t_not_at_s2  (2, 0)    2      (0, 0)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (2, 2)     (0, 2)
E             marker_t_not_at_s2  (2, 0)    3      (0, 0)  (2, 0)      SOURCE:(2, 2)  (2, 0)        (0, 2)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 0)  (2, 1)      SOURCE:(2, 1)  (0, 1)        (1, 0)     (0, 1)
E             marker_t_not_at_s2  (2, 1)    1      (1, 0)  (2, 1)      SOURCE:(1, 2)  (0, 1)        (2, 1)     (1, 0)
E             marker_t_not_at_s2  (2, 1)    2      (1, 0)  (2, 1)      SOURCE:(0, 1)  (0, 1)        (1, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 0)  (2, 1)      SOURCE:(1, 0)  (0, 1)        (0, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 0)  (2, 2)      SOURCE:(2, 2)  (0, 0)        (2, 0)     (0, 0)
E             marker_t_not_at_s2  (2, 2)    1      (2, 0)  (2, 2)      SOURCE:(0, 2)  (0, 0)        (2, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 2)    2      (2, 0)  (2, 2)      SOURCE:(0, 0)  (0, 0)        (0, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (2, 0)  (2, 2)      SOURCE:(2, 0)  (0, 0)        (0, 0)     (0, 2)
E             
E             Total failures: 32
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-R-8] ___________________
[gw2] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.R: 'R'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, R -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (0, 5)  (0, 0)      SOURCE:(0, 0)  (5, 5)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    1      (0, 5)  (0, 0)      SOURCE:(5, 0)  (5, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (0, 0)    2      (0, 5)  (0, 0)      SOURCE:(5, 5)  (5, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    3      (0, 5)  (0, 0)      SOURCE:(0, 5)  (5, 5)        (5, 5)     (5, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (1, 5)  (0, 1)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    1      (1, 5)  (0, 1)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (0, 1)    2      (1, 5)  (0, 1)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    3      (1, 5)  (0, 1)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (2, 5)  (0, 2)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    1      (2, 5)  (0, 2)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (0, 2)    2      (2, 5)  (0, 2)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    3      (2, 5)  (0, 2)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (3, 5)  (0, 3)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    1      (3, 5)  (0, 3)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (0, 3)    2      (3, 5)  (0, 3)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    3      (3, 5)  (0, 3)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (4, 5)  (0, 4)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    1      (4, 5)  (0, 4)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (0, 4)    2      (4, 5)  (0, 4)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    3      (4, 5)  (0, 4)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (5, 5)  (0, 5)      SOURCE:(5, 0)  (0, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    1      (5, 5)  (0, 5)      SOURCE:(5, 5)  (0, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (0, 5)    2      (5, 5)  (0, 5)      SOURCE:(0, 5)  (0, 5)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    3      (5, 5)  (0, 5)      SOURCE:(0, 0)  (0, 5)        (5, 0)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (0, 4)  (1, 0)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    1      (0, 4)  (1, 0)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (1, 0)    2      (0, 4)  (1, 0)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    3      (0, 4)  (1, 0)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (1, 4)  (1, 1)      SOURCE:(1, 1)  (4, 4)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    1      (1, 4)  (1, 1)      SOURCE:(4, 1)  (4, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (1, 1)    2      (1, 4)  (1, 1)      SOURCE:(4, 4)  (4, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    3      (1, 4)  (1, 1)      SOURCE:(1, 4)  (4, 4)        (4, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (2, 4)  (1, 2)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    1      (2, 4)  (1, 2)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (1, 2)    2      (2, 4)  (1, 2)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    3      (2, 4)  (1, 2)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (3, 4)  (1, 3)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    1      (3, 4)  (1, 3)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (1, 3)    2      (3, 4)  (1, 3)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    3      (3, 4)  (1, 3)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (4, 4)  (1, 4)      SOURCE:(4, 1)  (1, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    1      (4, 4)  (1, 4)      SOURCE:(4, 4)  (1, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (1, 4)    2      (4, 4)  (1, 4)      SOURCE:(1, 4)  (1, 4)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    3      (4, 4)  (1, 4)      SOURCE:(1, 1)  (1, 4)        (4, 1)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (5, 4)  (1, 5)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    1      (5, 4)  (1, 5)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (1, 5)    2      (5, 4)  (1, 5)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    3      (5, 4)  (1, 5)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (0, 3)  (2, 0)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    1      (0, 3)  (2, 0)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (2, 0)    2      (0, 3)  (2, 0)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    3      (0, 3)  (2, 0)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (1, 3)  (2, 1)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    1      (1, 3)  (2, 1)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (2, 1)    2      (1, 3)  (2, 1)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    3      (1, 3)  (2, 1)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (2, 3)  (2, 2)      SOURCE:(2, 2)  (3, 3)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    1      (2, 3)  (2, 2)      SOURCE:(3, 2)  (3, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (2, 2)    2      (2, 3)  (2, 2)      SOURCE:(3, 3)  (3, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    3      (2, 3)  (2, 2)      SOURCE:(2, 3)  (3, 3)        (3, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (3, 3)  (2, 3)      SOURCE:(3, 2)  (2, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    1      (3, 3)  (2, 3)      SOURCE:(3, 3)  (2, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (2, 3)    2      (3, 3)  (2, 3)      SOURCE:(2, 3)  (2, 3)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    3      (3, 3)  (2, 3)      SOURCE:(2, 2)  (2, 3)        (3, 2)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (4, 3)  (2, 4)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    1      (4, 3)  (2, 4)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (2, 4)    2      (4, 3)  (2, 4)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    3      (4, 3)  (2, 4)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (5, 3)  (2, 5)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    1      (5, 3)  (2, 5)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (2, 5)    2      (5, 3)  (2, 5)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    3      (5, 3)  (2, 5)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (0, 2)  (3, 0)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    1      (0, 2)  (3, 0)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (3, 0)    2      (0, 2)  (3, 0)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    3      (0, 2)  (3, 0)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (1, 2)  (3, 1)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    1      (1, 2)  (3, 1)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (3, 1)    2      (1, 2)  (3, 1)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    3      (1, 2)  (3, 1)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (2, 2)  (3, 2)      SOURCE:(2, 3)  (3, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    1      (2, 2)  (3, 2)      SOURCE:(2, 2)  (3, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (3, 2)    2      (2, 2)  (3, 2)      SOURCE:(3, 2)  (3, 2)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    3      (2, 2)  (3, 2)      SOURCE:(3, 3)  (3, 2)        (2, 3)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (3, 2)  (3, 3)      SOURCE:(3, 3)  (2, 2)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    1      (3, 2)  (3, 3)      SOURCE:(2, 3)  (2, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (3, 3)    2      (3, 2)  (3, 3)      SOURCE:(2, 2)  (2, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    3      (3, 2)  (3, 3)      SOURCE:(3, 2)  (2, 2)        (2, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (4, 2)  (3, 4)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    1      (4, 2)  (3, 4)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (3, 4)    2      (4, 2)  (3, 4)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    3      (4, 2)  (3, 4)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (5, 2)  (3, 5)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    1      (5, 2)  (3, 5)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (3, 5)    2      (5, 2)  (3, 5)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    3      (5, 2)  (3, 5)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (0, 1)  (4, 0)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    1      (0, 1)  (4, 0)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (4, 0)    2      (0, 1)  (4, 0)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    3      (0, 1)  (4, 0)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (1, 1)  (4, 1)      SOURCE:(1, 4)  (4, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    1      (1, 1)  (4, 1)      SOURCE:(1, 1)  (4, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (4, 1)    2      (1, 1)  (4, 1)      SOURCE:(4, 1)  (4, 1)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    3      (1, 1)  (4, 1)      SOURCE:(4, 4)  (4, 1)        (1, 4)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (2, 1)  (4, 2)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    1      (2, 1)  (4, 2)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (4, 2)    2      (2, 1)  (4, 2)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    3      (2, 1)  (4, 2)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (3, 1)  (4, 3)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    1      (3, 1)  (4, 3)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (4, 3)    2      (3, 1)  (4, 3)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    3      (3, 1)  (4, 3)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (4, 1)  (4, 4)      SOURCE:(4, 4)  (1, 1)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    1      (4, 1)  (4, 4)      SOURCE:(1, 4)  (1, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (4, 4)    2      (4, 1)  (4, 4)      SOURCE:(1, 1)  (1, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    3      (4, 1)  (4, 4)      SOURCE:(4, 1)  (1, 1)        (1, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (5, 1)  (4, 5)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    1      (5, 1)  (4, 5)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (4, 5)    2      (5, 1)  (4, 5)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    3      (5, 1)  (4, 5)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (0, 0)  (5, 0)      SOURCE:(0, 5)  (5, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    1      (0, 0)  (5, 0)      SOURCE:(0, 0)  (5, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (5, 0)    2      (0, 0)  (5, 0)      SOURCE:(5, 0)  (5, 0)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    3      (0, 0)  (5, 0)      SOURCE:(5, 5)  (5, 0)        (0, 5)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (1, 0)  (5, 1)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    1      (1, 0)  (5, 1)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (5, 1)    2      (1, 0)  (5, 1)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    3      (1, 0)  (5, 1)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (2, 0)  (5, 2)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    1      (2, 0)  (5, 2)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (5, 2)    2      (2, 0)  (5, 2)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    3      (2, 0)  (5, 2)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (3, 0)  (5, 3)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    1      (3, 0)  (5, 3)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (5, 3)    2      (3, 0)  (5, 3)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    3      (3, 0)  (5, 3)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (4, 0)  (5, 4)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    1      (4, 0)  (5, 4)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (5, 4)    2      (4, 0)  (5, 4)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    3      (4, 0)  (5, 4)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (5, 0)  (5, 5)      SOURCE:(5, 5)  (0, 0)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    1      (5, 0)  (5, 5)      SOURCE:(0, 5)  (0, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (5, 5)    2      (5, 0)  (5, 5)      SOURCE:(0, 0)  (0, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    3      (5, 0)  (5, 5)      SOURCE:(5, 0)  (0, 0)        (0, 0)     (0, 5)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
__________________ test_communicator_supported_pairs[D<-L-8] ___________________
[gw5] linux -- Python 3.11.14 /usr/local/bin/python

cube_size = 8, face_pair = (<FaceName.L: 'L'>, <FaceName.D: 'D'>)

    @pytest.mark.parametrize("cube_size", range(3, 9))  # All cube sizes
    @pytest.mark.parametrize("face_pair", SUPPORTED_PAIRS, ids=_face_pair_id)
    def test_communicator_supported_pairs(cube_size: int, face_pair: tuple[FaceName, FaceName]) -> None:
        """
        Test communicator for a specific face pair using the new execute_communicator API.
    
        VALIDATES THE 3-CYCLE PATTERN: s1 → t → s2 → s1
        ==================================================
        The block communicator moves exactly 3 pieces in a cycle:
        - s1: source point (natural source position)
        - t: target point (target block position)
        - s2: intermediate point (computed via target rotation on source face)
    
        For the given source/target pair:
        - Iterate all (ltr_y, ltr_x) positions in LTR coordinates
        - For each of 4 rotations, compute source position via execute_communicator (dry_run)
        - Place unique attribute on source piece
        - Execute communicator with new API
        - VERIFY 3-CYCLE POINTS: s1, t, s2 are correctly computed
        - Verify attribute moved from s1 to t (via s2)
        - Verify cube state preserved
    
        Known Limitations (Even Cubes):
        - Inner 2x2 positions may fail with M-slice sources (Up/Down/Back) due to
          M slice gap < 2. These positions work with E-slice sources (Left/Right).
        - Position (n//2, n//2) is truly unsupported by ALL sources.
        """
        source_face_name, target_face_name = face_pair
    
        app = AbstractApp.create_non_default(cube_size=cube_size, animation=False)
        solver = CageNxNSolver(app.op)
        helper = CommunicatorHelper(solver)
        cube = app.cube
        n_slices = cube.n_slices
    
        # Collect all failures and successes
        failures: list[dict[str, object]] = []
        successes: list[dict[str, object]] = []
    
        # Verify initial cube state
        assert _check_cube_state_preserved(cube), "Initial cube state should be valid"
    
        for ltr_y in range(n_slices):
            for ltr_x in range(n_slices):
                # Skip center position for odd cubes (invariant under rotation)
                if _is_center_position(n_slices, ltr_y, ltr_x):
                    continue
    
                source_face: Face = cube.face(source_face_name)
                target_face: Face = cube.face(target_face_name)
    
                target_point = (ltr_y, ltr_x)
    
                # Use NEW API: execute_communicator with dry_run to get natural source
                # and the 3-cycle points (s1, t, s2) WITHOUT modifying the cube
                target_block = (target_point, target_point)
                dry_result = helper.execute_communicator(
                    source_face=source_face,
                    target_face=target_face,
                    target_block=target_block,
                    dry_run=True  # Get natural source and cycle points
                )
    
                natural_source_point = dry_result.source_ltr
                cycle_s1 = dry_result.s1_point  # Natural source position
                cycle_t = dry_result.t_point    # Target position
                cycle_s2 = dry_result.s2_point  # Intermediate position
    
                for rotation in range(4):
                    # Reset cube to pristine state for each test iteration
                    cube = app.cube
                    cube.reset()
                    solver = CageNxNSolver(app.op)
                    helper = CommunicatorHelper(solver)
    
                    # Re-get faces from reset cube
                    source_face = cube.face(source_face_name)
                    target_face = cube.face(target_face_name)
    
                    target_block = (target_point, target_point)
    
                    # Get the cycle points from dry_run
                    dry_result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        dry_run=True
                    )
    
                    s1_point = dry_result.s1_point  # Natural source position
                    t_point = dry_result.t_point    # Target position
                    s2_point = dry_result.s2_point  # Intermediate position on source
    
                    # When we rotate the natural source, we also rotate s1 and s2 (both on source)
                    rotated_s1 = cube.cqr.rotate_point_clockwise(s1_point, rotation)
                    rotated_s2 = cube.cqr.rotate_point_clockwise(s2_point, rotation)
                    # t_point stays the same (on target face)
    
                    # ================================================================
                    # PLACE UNIQUE MARKERS ON ALL 3 CYCLE POINTS
                    # ================================================================
                    marker_s1_key = f"marker_s1_{uuid.uuid4().hex[:8]}"
                    marker_s1_value = f"s1_{uuid.uuid4().hex[:4]}"
    
                    marker_t_key = f"marker_t_{uuid.uuid4().hex[:8]}"
                    marker_t_value = f"t_{uuid.uuid4().hex[:4]}"
    
                    marker_s2_key = f"marker_s2_{uuid.uuid4().hex[:8]}"
                    marker_s2_value = f"s2_{uuid.uuid4().hex[:4]}"
    
                    # Mark s1 on source face
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    source_s1_piece.c_attributes[marker_s1_key] = marker_s1_value
    
                    # Mark t on target face
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    target_t_piece.c_attributes[marker_t_key] = marker_t_value
    
                    # Mark s2 on source face
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    source_s2_piece.c_attributes[marker_s2_key] = marker_s2_value
    
                    # ================================================================
                    # EXECUTE COMMUNICATOR
                    # ================================================================
                    result = helper.execute_communicator(
                        source_face=source_face,
                        target_face=target_face,
                        target_block=target_block,
                        source_block=(rotated_s1, rotated_s1),
                        preserve_state=True,
                        dry_run=False
                    )
    
                    alg = result.algorithm or Algs.NOOP
    
                    # Check cube state using relative consistency (not face.color)
                    state_preserved = _check_cube_state_preserved(cube)
    
                    # Common record data
                    record = {
                        "rotation": rotation,
                        "target_point": target_point,
                        "natural_source_point": natural_source_point,
                        "s1_point": s1_point,
                        "t_point": t_point,
                        "s2_point": s2_point,
                        "rotated_s1": rotated_s1,
                        "rotated_s2": rotated_s2,
                        "alg": alg,
                    }
    
                    # ================================================================
                    # VALIDATE 3-CYCLE: s1 → t → s2 → s1
                    # ================================================================
                    if not state_preserved:
                        failures.append({**record, "type": "state_not_preserved"})
                        continue
    
                    # Check marker_s1: should move from s1 to t
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_s1_key not in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_not_at_t"})
                        continue
                    if target_t_piece.c_attributes[marker_s1_key] != marker_s1_value:
                        failures.append({**record, "type": "marker_s1_value_mismatch"})
                        continue
    
                    # Check marker_t: should move from t to s2
                    # SEARCH for where marker_t actually ended up
                    marker_t_found_location = None
                    marker_t_found_on_face = None
    
                    # Search on source face
                    for search_y in range(n_slices):
                        for search_x in range(n_slices):
                            search_point = (search_y, search_x)
                            search_piece = source_face.center.get_center_slice(search_point).edge
                            if marker_t_key in search_piece.c_attributes:
                                marker_t_found_location = search_point
                                marker_t_found_on_face = "SOURCE"
                                break
                        if marker_t_found_location:
                            break
    
                    # Search on target face if not found on source
                    if not marker_t_found_location:
                        for search_y in range(n_slices):
                            for search_x in range(n_slices):
                                search_point = (search_y, search_x)
                                search_piece = target_face.center.get_center_slice(search_point).edge
                                if marker_t_key in search_piece.c_attributes:
                                    marker_t_found_location = search_point
                                    marker_t_found_on_face = "TARGET"
                                    break
                            if marker_t_found_location:
                                break
    
                    record["marker_t_found_location"] = marker_t_found_location
                    record["marker_t_found_on_face"] = marker_t_found_on_face
    
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_t_key not in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_not_at_s2"})
                        continue
                    if source_s2_piece.c_attributes[marker_t_key] != marker_t_value:
                        failures.append({**record, "type": "marker_t_value_mismatch"})
                        continue
    
                    # Check marker_s2: should move from s2 back to s1
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s2_key not in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_not_at_s1"})
                        continue
                    if source_s1_piece.c_attributes[marker_s2_key] != marker_s2_value:
                        failures.append({**record, "type": "marker_s2_value_mismatch"})
                        continue
    
                    # Verify markers are NOT in their original positions (they moved!)
                    # marker_s1 original position was s1 (on source face)
                    source_s1_piece = source_face.center.get_center_slice(rotated_s1).edge
                    if marker_s1_key in source_s1_piece.c_attributes:
                        failures.append({**record, "type": "marker_s1_still_on_original_s1"})
                        continue
    
                    # marker_t original position was t (on target face)
                    target_t_piece = target_face.center.get_center_slice(t_point).edge
                    if marker_t_key in target_t_piece.c_attributes:
                        failures.append({**record, "type": "marker_t_still_on_original_t"})
                        continue
    
                    # marker_s2 original position was s2 (on source face)
                    source_s2_piece = source_face.center.get_center_slice(rotated_s2).edge
                    if marker_s2_key in source_s2_piece.c_attributes:
                        failures.append({**record, "type": "marker_s2_still_on_original_s2"})
                        continue
    
                    # All checks passed - record success
                    # Add marker_t location info (should be at rotated_s2 on source face)
                    record["marker_t_found_on_face"] = "SOURCE"
                    record["marker_t_found_location"] = rotated_s2
                    successes.append({**record, "type": "OK_3CYCLE"})
    
        # At end of test, report all failures in a table
        if failures:
            # Get target points that have failures
            failed_targets = {f['target_point'] for f in failures}
    
            # Get successes for failed target points
            relevant_successes = [s for s in successes if s['target_point'] in failed_targets]
    
            # Combine failures and successes, sort by target point then type (failures first) then rotation
            all_records = failures + relevant_successes
            all_records.sort(key=lambda x: (
                x['target_point'],
                0 if x['type'] != "OK" else 1,  # Failures before successes
                x['rotation']
            ))
    
            # Build failure table using tabulate
            header = f"Cube size={cube_size}, {source_face_name.name} -> {target_face_name.name}"
    
            # Build table rows, inserting separator rows between target point groups
            table_data: list[list[object]] = []
            prev_target: object = None
            for r in all_records:
                # Add separator between different target points
                if prev_target is not None and r['target_point'] != prev_target:
                    table_data.append(["---"] * 9)  # 9 columns
                prev_target = r['target_point']
    
                marker_t_found_on_face = r.get('marker_t_found_on_face', '?')
                marker_t_found_location = r.get('marker_t_found_location', '?')
    
                table_data.append([
                    r['type'],
                    r['target_point'],
                    r['rotation'],
                    r['s1_point'],
                    r['t_point'],
                    f"{marker_t_found_on_face}:{marker_t_found_location}",
                    r['s2_point'],
                    r['rotated_s1'],
                    r['rotated_s2'],
                ])
    
            # Use multi-line headers to keep table narrow
            headers = ["Type", "Target\nPoint", "Rot", "s1", "t\n(Target)", "Marker_T\nFound", "s2\n(Computed)", "Rotated\nS1", "Rotated\nS2"]
            table_str = tabulate(table_data, headers=headers, tablefmt="simple")
    
            msg = f"\n{header}\n{'=' * len(header)}\n{table_str}\n\nTotal failures: {len(failures)}"
>           assert False, msg
E           AssertionError: 
E             Cube size=8, L -> D
E             ===================
E             Type                Target    Rot    s1      t           Marker_T       s2            Rotated    Rotated
E                                 Point                    (Target)    Found          (Computed)    S1         S2
E             ------------------  --------  -----  ------  ----------  -------------  ------------  ---------  ---------
E             marker_t_not_at_s2  (0, 0)    0      (5, 0)  (0, 0)      SOURCE:(5, 5)  (0, 0)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (0, 0)    1      (5, 0)  (0, 0)      SOURCE:(0, 5)  (0, 0)        (5, 5)     (5, 0)
E             marker_t_not_at_s2  (0, 0)    2      (5, 0)  (0, 0)      SOURCE:(0, 0)  (0, 0)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (0, 0)    3      (5, 0)  (0, 0)      SOURCE:(5, 0)  (0, 0)        (0, 0)     (0, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 1)    0      (4, 0)  (0, 1)      SOURCE:(5, 4)  (0, 1)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (0, 1)    1      (4, 0)  (0, 1)      SOURCE:(1, 5)  (0, 1)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (0, 1)    2      (4, 0)  (0, 1)      SOURCE:(0, 1)  (0, 1)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (0, 1)    3      (4, 0)  (0, 1)      SOURCE:(4, 0)  (0, 1)        (0, 1)     (1, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 2)    0      (3, 0)  (0, 2)      SOURCE:(5, 3)  (0, 2)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (0, 2)    1      (3, 0)  (0, 2)      SOURCE:(2, 5)  (0, 2)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (0, 2)    2      (3, 0)  (0, 2)      SOURCE:(0, 2)  (0, 2)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (0, 2)    3      (3, 0)  (0, 2)      SOURCE:(3, 0)  (0, 2)        (0, 2)     (2, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 3)    0      (2, 0)  (0, 3)      SOURCE:(5, 2)  (0, 3)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (0, 3)    1      (2, 0)  (0, 3)      SOURCE:(3, 5)  (0, 3)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (0, 3)    2      (2, 0)  (0, 3)      SOURCE:(0, 3)  (0, 3)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (0, 3)    3      (2, 0)  (0, 3)      SOURCE:(2, 0)  (0, 3)        (0, 3)     (3, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 4)    0      (1, 0)  (0, 4)      SOURCE:(5, 1)  (0, 4)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (0, 4)    1      (1, 0)  (0, 4)      SOURCE:(4, 5)  (0, 4)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (0, 4)    2      (1, 0)  (0, 4)      SOURCE:(0, 4)  (0, 4)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (0, 4)    3      (1, 0)  (0, 4)      SOURCE:(1, 0)  (0, 4)        (0, 4)     (4, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (0, 5)    0      (0, 0)  (0, 5)      SOURCE:(0, 5)  (5, 0)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (0, 5)    1      (0, 0)  (0, 5)      SOURCE:(0, 0)  (5, 0)        (5, 0)     (5, 5)
E             marker_t_not_at_s2  (0, 5)    2      (0, 0)  (0, 5)      SOURCE:(5, 0)  (5, 0)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (0, 5)    3      (0, 0)  (0, 5)      SOURCE:(5, 5)  (5, 0)        (0, 5)     (0, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 0)    0      (5, 1)  (1, 0)      SOURCE:(4, 5)  (1, 0)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (1, 0)    1      (5, 1)  (1, 0)      SOURCE:(0, 4)  (1, 0)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (1, 0)    2      (5, 1)  (1, 0)      SOURCE:(1, 0)  (1, 0)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (1, 0)    3      (5, 1)  (1, 0)      SOURCE:(5, 1)  (1, 0)        (1, 0)     (0, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 1)    0      (4, 1)  (1, 1)      SOURCE:(4, 4)  (1, 1)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (1, 1)    1      (4, 1)  (1, 1)      SOURCE:(1, 4)  (1, 1)        (4, 4)     (4, 1)
E             marker_t_not_at_s2  (1, 1)    2      (4, 1)  (1, 1)      SOURCE:(1, 1)  (1, 1)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (1, 1)    3      (4, 1)  (1, 1)      SOURCE:(4, 1)  (1, 1)        (1, 1)     (1, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 2)    0      (3, 1)  (1, 2)      SOURCE:(4, 3)  (1, 2)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (1, 2)    1      (3, 1)  (1, 2)      SOURCE:(2, 4)  (1, 2)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (1, 2)    2      (3, 1)  (1, 2)      SOURCE:(1, 2)  (1, 2)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (1, 2)    3      (3, 1)  (1, 2)      SOURCE:(3, 1)  (1, 2)        (1, 2)     (2, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 3)    0      (2, 1)  (1, 3)      SOURCE:(4, 2)  (1, 3)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (1, 3)    1      (2, 1)  (1, 3)      SOURCE:(3, 4)  (1, 3)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (1, 3)    2      (2, 1)  (1, 3)      SOURCE:(1, 3)  (1, 3)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (1, 3)    3      (2, 1)  (1, 3)      SOURCE:(2, 1)  (1, 3)        (1, 3)     (3, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 4)    0      (1, 1)  (1, 4)      SOURCE:(1, 4)  (4, 1)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (1, 4)    1      (1, 1)  (1, 4)      SOURCE:(1, 1)  (4, 1)        (4, 1)     (4, 4)
E             marker_t_not_at_s2  (1, 4)    2      (1, 1)  (1, 4)      SOURCE:(4, 1)  (4, 1)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (1, 4)    3      (1, 1)  (1, 4)      SOURCE:(4, 4)  (4, 1)        (1, 4)     (1, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (1, 5)    0      (0, 1)  (1, 5)      SOURCE:(4, 0)  (1, 5)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (1, 5)    1      (0, 1)  (1, 5)      SOURCE:(5, 4)  (1, 5)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (1, 5)    2      (0, 1)  (1, 5)      SOURCE:(1, 5)  (1, 5)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (1, 5)    3      (0, 1)  (1, 5)      SOURCE:(0, 1)  (1, 5)        (1, 5)     (5, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 0)    0      (5, 2)  (2, 0)      SOURCE:(3, 5)  (2, 0)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (2, 0)    1      (5, 2)  (2, 0)      SOURCE:(0, 3)  (2, 0)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (2, 0)    2      (5, 2)  (2, 0)      SOURCE:(2, 0)  (2, 0)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (2, 0)    3      (5, 2)  (2, 0)      SOURCE:(5, 2)  (2, 0)        (2, 0)     (0, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 1)    0      (4, 2)  (2, 1)      SOURCE:(3, 4)  (2, 1)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (2, 1)    1      (4, 2)  (2, 1)      SOURCE:(1, 3)  (2, 1)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (2, 1)    2      (4, 2)  (2, 1)      SOURCE:(2, 1)  (2, 1)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (2, 1)    3      (4, 2)  (2, 1)      SOURCE:(4, 2)  (2, 1)        (2, 1)     (1, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 2)    0      (3, 2)  (2, 2)      SOURCE:(3, 3)  (2, 2)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (2, 2)    1      (3, 2)  (2, 2)      SOURCE:(2, 3)  (2, 2)        (3, 3)     (3, 2)
E             marker_t_not_at_s2  (2, 2)    2      (3, 2)  (2, 2)      SOURCE:(2, 2)  (2, 2)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (2, 2)    3      (3, 2)  (2, 2)      SOURCE:(3, 2)  (2, 2)        (2, 2)     (2, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 3)    0      (2, 2)  (2, 3)      SOURCE:(2, 3)  (3, 2)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (2, 3)    1      (2, 2)  (2, 3)      SOURCE:(2, 2)  (3, 2)        (3, 2)     (3, 3)
E             marker_t_not_at_s2  (2, 3)    2      (2, 2)  (2, 3)      SOURCE:(3, 2)  (3, 2)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (2, 3)    3      (2, 2)  (2, 3)      SOURCE:(3, 3)  (3, 2)        (2, 3)     (2, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 4)    0      (1, 2)  (2, 4)      SOURCE:(3, 1)  (2, 4)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (2, 4)    1      (1, 2)  (2, 4)      SOURCE:(4, 3)  (2, 4)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (2, 4)    2      (1, 2)  (2, 4)      SOURCE:(2, 4)  (2, 4)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (2, 4)    3      (1, 2)  (2, 4)      SOURCE:(1, 2)  (2, 4)        (2, 4)     (4, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (2, 5)    0      (0, 2)  (2, 5)      SOURCE:(3, 0)  (2, 5)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (2, 5)    1      (0, 2)  (2, 5)      SOURCE:(5, 3)  (2, 5)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (2, 5)    2      (0, 2)  (2, 5)      SOURCE:(2, 5)  (2, 5)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (2, 5)    3      (0, 2)  (2, 5)      SOURCE:(0, 2)  (2, 5)        (2, 5)     (5, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 0)    0      (5, 3)  (3, 0)      SOURCE:(2, 5)  (3, 0)        (5, 3)     (3, 0)
E             marker_t_not_at_s2  (3, 0)    1      (5, 3)  (3, 0)      SOURCE:(0, 2)  (3, 0)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (3, 0)    2      (5, 3)  (3, 0)      SOURCE:(3, 0)  (3, 0)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (3, 0)    3      (5, 3)  (3, 0)      SOURCE:(5, 3)  (3, 0)        (3, 0)     (0, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 1)    0      (4, 3)  (3, 1)      SOURCE:(2, 4)  (3, 1)        (4, 3)     (3, 1)
E             marker_t_not_at_s2  (3, 1)    1      (4, 3)  (3, 1)      SOURCE:(1, 2)  (3, 1)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (3, 1)    2      (4, 3)  (3, 1)      SOURCE:(3, 1)  (3, 1)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (3, 1)    3      (4, 3)  (3, 1)      SOURCE:(4, 3)  (3, 1)        (3, 1)     (1, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 2)    0      (3, 3)  (3, 2)      SOURCE:(3, 2)  (2, 3)        (3, 3)     (2, 3)
E             marker_t_not_at_s2  (3, 2)    1      (3, 3)  (3, 2)      SOURCE:(3, 3)  (2, 3)        (2, 3)     (2, 2)
E             marker_t_not_at_s2  (3, 2)    2      (3, 3)  (3, 2)      SOURCE:(2, 3)  (2, 3)        (2, 2)     (3, 2)
E             marker_t_not_at_s2  (3, 2)    3      (3, 3)  (3, 2)      SOURCE:(2, 2)  (2, 3)        (3, 2)     (3, 3)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 3)    0      (2, 3)  (3, 3)      SOURCE:(2, 2)  (3, 3)        (2, 3)     (3, 3)
E             marker_t_not_at_s2  (3, 3)    1      (2, 3)  (3, 3)      SOURCE:(3, 2)  (3, 3)        (2, 2)     (2, 3)
E             marker_t_not_at_s2  (3, 3)    2      (2, 3)  (3, 3)      SOURCE:(3, 3)  (3, 3)        (3, 2)     (2, 2)
E             marker_t_not_at_s2  (3, 3)    3      (2, 3)  (3, 3)      SOURCE:(2, 3)  (3, 3)        (3, 3)     (3, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 4)    0      (1, 3)  (3, 4)      SOURCE:(2, 1)  (3, 4)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (3, 4)    1      (1, 3)  (3, 4)      SOURCE:(4, 2)  (3, 4)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (3, 4)    2      (1, 3)  (3, 4)      SOURCE:(3, 4)  (3, 4)        (4, 2)     (2, 1)
E             marker_t_not_at_s2  (3, 4)    3      (1, 3)  (3, 4)      SOURCE:(1, 3)  (3, 4)        (3, 4)     (4, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (3, 5)    0      (0, 3)  (3, 5)      SOURCE:(2, 0)  (3, 5)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (3, 5)    1      (0, 3)  (3, 5)      SOURCE:(5, 2)  (3, 5)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (3, 5)    2      (0, 3)  (3, 5)      SOURCE:(3, 5)  (3, 5)        (5, 2)     (2, 0)
E             marker_t_not_at_s2  (3, 5)    3      (0, 3)  (3, 5)      SOURCE:(0, 3)  (3, 5)        (3, 5)     (5, 2)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 0)    0      (5, 4)  (4, 0)      SOURCE:(1, 5)  (4, 0)        (5, 4)     (4, 0)
E             marker_t_not_at_s2  (4, 0)    1      (5, 4)  (4, 0)      SOURCE:(0, 1)  (4, 0)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (4, 0)    2      (5, 4)  (4, 0)      SOURCE:(4, 0)  (4, 0)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (4, 0)    3      (5, 4)  (4, 0)      SOURCE:(5, 4)  (4, 0)        (4, 0)     (0, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 1)    0      (4, 4)  (4, 1)      SOURCE:(4, 1)  (1, 4)        (4, 4)     (1, 4)
E             marker_t_not_at_s2  (4, 1)    1      (4, 4)  (4, 1)      SOURCE:(4, 4)  (1, 4)        (1, 4)     (1, 1)
E             marker_t_not_at_s2  (4, 1)    2      (4, 4)  (4, 1)      SOURCE:(1, 4)  (1, 4)        (1, 1)     (4, 1)
E             marker_t_not_at_s2  (4, 1)    3      (4, 4)  (4, 1)      SOURCE:(1, 1)  (1, 4)        (4, 1)     (4, 4)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 2)    0      (3, 4)  (4, 2)      SOURCE:(1, 3)  (4, 2)        (3, 4)     (4, 2)
E             marker_t_not_at_s2  (4, 2)    1      (3, 4)  (4, 2)      SOURCE:(2, 1)  (4, 2)        (1, 3)     (3, 4)
E             marker_t_not_at_s2  (4, 2)    2      (3, 4)  (4, 2)      SOURCE:(4, 2)  (4, 2)        (2, 1)     (1, 3)
E             marker_t_not_at_s2  (4, 2)    3      (3, 4)  (4, 2)      SOURCE:(3, 4)  (4, 2)        (4, 2)     (2, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 3)    0      (2, 4)  (4, 3)      SOURCE:(1, 2)  (4, 3)        (2, 4)     (4, 3)
E             marker_t_not_at_s2  (4, 3)    1      (2, 4)  (4, 3)      SOURCE:(3, 1)  (4, 3)        (1, 2)     (2, 4)
E             marker_t_not_at_s2  (4, 3)    2      (2, 4)  (4, 3)      SOURCE:(4, 3)  (4, 3)        (3, 1)     (1, 2)
E             marker_t_not_at_s2  (4, 3)    3      (2, 4)  (4, 3)      SOURCE:(2, 4)  (4, 3)        (4, 3)     (3, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 4)    0      (1, 4)  (4, 4)      SOURCE:(1, 1)  (4, 4)        (1, 4)     (4, 4)
E             marker_t_not_at_s2  (4, 4)    1      (1, 4)  (4, 4)      SOURCE:(4, 1)  (4, 4)        (1, 1)     (1, 4)
E             marker_t_not_at_s2  (4, 4)    2      (1, 4)  (4, 4)      SOURCE:(4, 4)  (4, 4)        (4, 1)     (1, 1)
E             marker_t_not_at_s2  (4, 4)    3      (1, 4)  (4, 4)      SOURCE:(1, 4)  (4, 4)        (4, 4)     (4, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (4, 5)    0      (0, 4)  (4, 5)      SOURCE:(1, 0)  (4, 5)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (4, 5)    1      (0, 4)  (4, 5)      SOURCE:(5, 1)  (4, 5)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (4, 5)    2      (0, 4)  (4, 5)      SOURCE:(4, 5)  (4, 5)        (5, 1)     (1, 0)
E             marker_t_not_at_s2  (4, 5)    3      (0, 4)  (4, 5)      SOURCE:(0, 4)  (4, 5)        (4, 5)     (5, 1)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 0)    0      (5, 5)  (5, 0)      SOURCE:(5, 0)  (0, 5)        (5, 5)     (0, 5)
E             marker_t_not_at_s2  (5, 0)    1      (5, 5)  (5, 0)      SOURCE:(5, 5)  (0, 5)        (0, 5)     (0, 0)
E             marker_t_not_at_s2  (5, 0)    2      (5, 5)  (5, 0)      SOURCE:(0, 5)  (0, 5)        (0, 0)     (5, 0)
E             marker_t_not_at_s2  (5, 0)    3      (5, 5)  (5, 0)      SOURCE:(0, 0)  (0, 5)        (5, 0)     (5, 5)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 1)    0      (4, 5)  (5, 1)      SOURCE:(0, 4)  (5, 1)        (4, 5)     (5, 1)
E             marker_t_not_at_s2  (5, 1)    1      (4, 5)  (5, 1)      SOURCE:(1, 0)  (5, 1)        (0, 4)     (4, 5)
E             marker_t_not_at_s2  (5, 1)    2      (4, 5)  (5, 1)      SOURCE:(5, 1)  (5, 1)        (1, 0)     (0, 4)
E             marker_t_not_at_s2  (5, 1)    3      (4, 5)  (5, 1)      SOURCE:(4, 5)  (5, 1)        (5, 1)     (1, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 2)    0      (3, 5)  (5, 2)      SOURCE:(0, 3)  (5, 2)        (3, 5)     (5, 2)
E             marker_t_not_at_s2  (5, 2)    1      (3, 5)  (5, 2)      SOURCE:(2, 0)  (5, 2)        (0, 3)     (3, 5)
E             marker_t_not_at_s2  (5, 2)    2      (3, 5)  (5, 2)      SOURCE:(5, 2)  (5, 2)        (2, 0)     (0, 3)
E             marker_t_not_at_s2  (5, 2)    3      (3, 5)  (5, 2)      SOURCE:(3, 5)  (5, 2)        (5, 2)     (2, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 3)    0      (2, 5)  (5, 3)      SOURCE:(0, 2)  (5, 3)        (2, 5)     (5, 3)
E             marker_t_not_at_s2  (5, 3)    1      (2, 5)  (5, 3)      SOURCE:(3, 0)  (5, 3)        (0, 2)     (2, 5)
E             marker_t_not_at_s2  (5, 3)    2      (2, 5)  (5, 3)      SOURCE:(5, 3)  (5, 3)        (3, 0)     (0, 2)
E             marker_t_not_at_s2  (5, 3)    3      (2, 5)  (5, 3)      SOURCE:(2, 5)  (5, 3)        (5, 3)     (3, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 4)    0      (1, 5)  (5, 4)      SOURCE:(0, 1)  (5, 4)        (1, 5)     (5, 4)
E             marker_t_not_at_s2  (5, 4)    1      (1, 5)  (5, 4)      SOURCE:(4, 0)  (5, 4)        (0, 1)     (1, 5)
E             marker_t_not_at_s2  (5, 4)    2      (1, 5)  (5, 4)      SOURCE:(5, 4)  (5, 4)        (4, 0)     (0, 1)
E             marker_t_not_at_s2  (5, 4)    3      (1, 5)  (5, 4)      SOURCE:(1, 5)  (5, 4)        (5, 4)     (4, 0)
E             ---                 ---       ---    ---     ---         ---            ---           ---        ---
E             marker_t_not_at_s2  (5, 5)    0      (0, 5)  (5, 5)      SOURCE:(0, 0)  (5, 5)        (0, 5)     (5, 5)
E             marker_t_not_at_s2  (5, 5)    1      (0, 5)  (5, 5)      SOURCE:(5, 0)  (5, 5)        (0, 0)     (0, 5)
E             marker_t_not_at_s2  (5, 5)    2      (0, 5)  (5, 5)      SOURCE:(5, 5)  (5, 5)        (5, 0)     (0, 0)
E             marker_t_not_at_s2  (5, 5)    3      (0, 5)  (5, 5)      SOURCE:(0, 5)  (5, 5)        (5, 5)     (5, 0)
E             
E             Total failures: 144
E           assert False

tests/solvers/test_communicator_helper.py:489: AssertionError
=========================== short test summary info ============================
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-8]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-U-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[R<-D-8]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-D-8]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-8]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[L<-U-8]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-L-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[U<-R-8]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-4]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-6]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-7]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-5]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-R-8]
FAILED tests/solvers/test_communicator_helper.py::test_communicator_supported_pairs[D<-L-8]
======================= 40 failed, 140 passed in 17.30s ========================
